# 2장. 스타일 구문 만들기

이전 장에서는 다음 장에서부터 구축할 부트스트랩 웹 사이트인 `MyPhoto`를 처음 보았습니다. 이제 직접 만들어볼 시간이며, 실제로 이 웹사이트의 첫 번째 섹션인 주문할 수 있는 출력물 크기의 목록을 제공하는 Services 섹션을 만들 것입니다. 부트스트랩의 그리드 시스템을 사용하여 그리드를 구축하고, 그리드 시스템 내에서 이미지 요소를 만들어 이미지 수정자를 적용합니다. 그리고 부트스트랩의 유틸리티 클래스를 활용하여 다양한 디스플레이의 해상도에 맞게 시각적인 표시기와 최적화 된 레이아웃을 만듭니다.

이 장의 끝에서 코드 예제와 부트스트랩 소스 코드를 학습할 것이며, 다음의 것들을 보다 깊이있게 이해할 수 있게 될 것입니다.

* 부트스트랩의 그리드 시스템
* 부트스트랩 안에서의 반응형 이미지
* 부트스트랩의 도우미 클래스
* 부트스트랩의 반응형 유틸리티

## 그리드 시스템

부트스트랩의 그리드 시스템은 틀림없이 가장 인상적이면서도 일반적으로 사용되는 기능입니다. 따라서 그리드 시스템이 페이지 레이아웃과 관련된 여러 가지 문제점, 특히 반응이 빠른 페이지 레이아웃을 제거하므로 모든 부트스트랩 개발자는 이것을 습득하는 것이 중요합니다. 그리드 시스템은 페이지의 내용을 수평 및 수직으로 배치하는 것과 같은 이슈를 해결하고 여러 디스플레이의 너비에 걸친 페이지의 구조적인 문제를 해결합니다.

**1장. 부트스트랩 올리기**에서 이미 언급했듯이, 부트스트랩 4는 모바일을 우선으로 합니다. 그리드 시스템이 더 작은 뷰포트로 최적화 되고 더 작은 뷰포트로 축소하는 대신 큰 뷰포트에 맞게 스케일링 되는 것은 전혀 놀라운 일이 아닙니다.

> **참고**
>
> 뷰포트란?
>
> 뷰포트는 페이지 내용을 렌더링 할 때 사용할 수 있는 크기의 표시입니다. 예를 들어 디스플레이의 툴바, 스크롤 막대 등 브라우저 창의 크기가 뷰포트입니다. **1장 부트스트랩 올리기**에서 이미 언급했듯이 휴대 기기는 모바일 장치에서 표시하기에 최적화 되지 않은 웹사이트를 표시할 수 있도록 뷰포트가 실제보다 크게 표시될 수 있습니다. 결과적으로 모바일 뷰포트를 고려한 웹사이트는 의도한데로 렌더링 되지 않을 수 있습니다. 해결 방법인 `viewport` 메타 태그는 iOS에서 애플에 의해 도입된 이후 다른 모든 주요 브라우저에서 동일하게 채택되었습니다. `viewport` 메타 태그를 사용하면, 뷰포트의 표시 크기를 정의할 수 있습니다.

그리드는 뚜렷하며 근본적으로 연결된 파트로 구성되는 구조입니다. 모든 캡슐화 컨테이너가 수평 행으로 분리가 되며, 그 자체가 12개의 동일한 열로 나뉩니다. 부트스트랩의 그리드 시스템의 세 가지 빌딩 블록에 대해 깊이있게 살펴보겠습니다.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_001.jpg)

*그림 2.1*: 부트스트랩 그리드 구조: 행과 12개의 열로 구성된 표와 같은 구조로 되어 있는 컨테이너(가장 바깥쪽 상자). 행은 컨테이너 내부에 포함되어야 합니다. 마찬가지로 열은 행 컨텍스트 내에만 존재할 수 있습니다. 테이블은 테이블을 구성하는 데 사용할 수 있지만, 테이블 자체로는 아닙니다. 테이블과 달리 독립적인 행은 다른 수의 열로 구성될 수 있습니다. 예를 들어 행 1은 12개의 열로 구성될 수 있고 행 2는 세 개의 열만 포함할 수 있습니다.

> **참고**
>
> Flexbox 지원
>
> Flexbox는 블록, 인라인, 표배치와 같은 CSS2 레이아웃 모듈과 달리 복잡한 레이아웃을 간단하게 구현할 수 있는 CSS 박스 모델입니다. Flexbox는 간단한 룰 세트를 통해 레이아웃이 사용 가능한 공간을 최대한 활용하도록 설계되었습니다. 부트스트랩 4는 개발자가 `_variables.scss-$enabled-flex`에서 하나의 변수를 변경하여 특정 구성 요소에 대해 Flexbox를 사용하도록 프레임워크를 구성하게 해줍니다. `$enable-flex`를 `true`로 설정하고 부트스트랩을 다시 컴파일 하면, 여러 부트스트랩 구성 요소의 표시 속성이 `flex`로 설정됩니다. 여기에는 그리드 시스템 자체와 입력 그룹 및 미디어 컴포넌트가 포함됩니다. Flexbox에 대한 자세한 내용은 [https://www.w3.org/TR/css-flexbox-1/](https://www.w3.org/TR/css-flexbox-1/)에서 확인할 수 있습니다.

### 컨테이너

컨테이너는 부트스트랩의 그리드 시스템에서의 핵심이며, 사실상 모든 부트스트랩 페이지의 부모입니다. 컨테이너는 정확하게 들리는 소리와도 같은 것입니다. 페이지의 섹션 내에서 다른 모든 내용들을 캡슐화 하여, 섹션의 렌더링 방법에 대한 기초를 제공합니다. 컨테이너를 환경에 따라 변형할 수 있는 캔버스에 콘텐츠를 표시될 수 있도록 브라우저 창이 컨테이너를 캔버스로 나타내는 것을 생각할 수 있습니다. 명시적으로 지정하지 않으면, 뷰포트에 관계 없이 콘텐츠가 이 캔버스의 외부로 삽입되지 않습니다. 컨테이너는 하나의 루트 컨테이너 요소가 있는 페이지의 전체 내용이나 수 많은 컨테이너 요소가 있는 페이지의 다른 섹션에 적용할 수 있습니다.

부트스트랩에서 제공하는 컨테이너 클래스에는 `container`와 `container-fluid` 두 가지의 유형이 있습니다.

#### container

`container` 클래스는 페이지의 내용을 고정폭으로 렌더링 합니다. 이 너비는 일반적으로 CSS의 미디어 쿼리를 활용하여 가장 적합한 너비를 결정하는 뷰포트의 너비를 기반으로 합니다.

> **참고**
>
> 미디어 쿼리란?
>
> 미디어 쿼리는 부울 값으로 해석되는 표현식입니다. 이것은 다양한 미디어 유형에 대한 스타일을 정의하는 `@media` 규칙을 트리거하는 데 사용합니다. 자세한 내용은 [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries)를 참고하세요.

그리드 시스템에는 `_variables.scss`에 정의 된 5개의 핵심 **중단점(breakpoint)**이 있습니다. 이들은 초소형(`xs`), 소형(`sm`), 중형(`md`), 대형(`lg`) 및 초대형(`xl`)입니다.

> **참고**
>
> 중단점(브레이크 포인트)란?
>
> 웹 개발에서 레이아웃과 관련한 중단점(브레이크 포인트)은 스타일 규칙이 변경되는 것에 대해 미리 정의된 수직 및 수평 치수입니다. 하나의 규칙이 깨지게 되면, 다른 최적화 된 규칙 집합이 트리거 됩니다. 이러한 규칙은 미디어 쿼리에 의해 트리거 되어 뷰포트의 크기를 요청합니다. 예를 들어 `@media(min-width: 768px)`의 경우 뷰포트가 `768px` 이상인 경우의 규칙들을 트리거 합니다.


`_variables.scss`를 살펴보기 바랍니다.

```css
$grid-breakpoints: (
    // Extra small screen / phone
    xs: 0,
    // Small screen / phone
    sm: 544px,
    // Medium screen / tablet
    md: 768px,
    // Large screen / desktop
    lg: 992px,
    // Extra large screen / wide desktop
    xl: 1200px
    ) !default; 
```

여기에서 부트스트랩은 5개의 중단점의 최소 및 최대 폭 변수 값과 관련한 디스플레이의 유형을 정의합니다. 부트스트랩은 중단점을 `$grid-breakpoints` 속성으로 접근할 수 있으므로 모든 Sass 코드에서 이러한 변수를 참조합니다. 또한 적절한 중단점과 관련한 다양한 컨테이너 크기의 변수를 볼 수 있습니다. 다음 코드를 살펴보세요.

```css
// Grid containers
//
// Define the maximum width of `.container` for different screen sizes.
$container-max-widths: (
    sm: 576px,
    md: 720px,
    lg: 940px,
    xl: 1140px
) !default;
// Grid columns
//
// Set the number of columns and specify the width of the gutters.
$grid-columns: 12 !default;
$grid-gutter-width:    1.875rem !default; // 30px 
```

예를 들면, `container-tablet`은 750px로 설정되어 있습니다. `720px`과 `30px`의 `grid-gutter-width`의 값의 합입니다. 코드 안의 주석에서 볼 수 있듯이, `container-**`은 `screen-**`과 직접 관련이 됩니다. 그런 다음 크기는 `grid.scss`의 미디어 쿼리를 통해 활용되어 컨테이너의 원하는 너비를 설정합니다. `.container` 클래스에서 `_grid.scss`를 살펴보겠습니다.

```css
.container {
    @include make-container();
    @include make-container-max-widths();
} 
```

이 내용을 알아보겠습니다.

`make-container()`와 `make-container-max-width()`는 뷰포트 안 가운데 컨테이너에 대한 규칙을 집중시키고 최대 너비 규칙을 각각 설정하는 규칙을 가진 믹스인입니다. `make-container` 믹스인은 `padding`과 `margin` 규칙을 사용하여 컨테이너 정렬을 중앙 집중화 합니다. 다음 코드를 살펴보세요.

```css
@mixin make-container($gutter: $grid-gutter-width) {
    margin-left: auto;
    margin-right: auto;
    padding-left: ($gutter / 2);
    padding-right: ($gutter / 2);
    @if not $enable-flex {
        @include clearfix();
    }
}
```

`make-container-max-widths` 믹스인은 더 복잡합니다. 믹스인은 `$grid-breakpoints`와 동의어인 전역적인 `$breakpoint` 변수를 반복하고, 미디어 쿼리를 사용하여 각 중단점에 대한 최대 너비 규칙을 설정합니다. 다음 코드를 살펴보세요.

```css
// For each breakpoint, define the maximum width of the
container in a media query
@mixin make-container-max-widths($max-widths: $container-max-widths) {
    @each $breakpoint, $container-max-width in $max-widths {
        @include media-breakpoint-up($breakpoint) {
            max-width: $container-max-width;
        }
    }
} 
```

완성된 코드는 다음과 같습니다.

```css
@media (min-width: 544px) {
    .container {
        max-width: 576px;
    }
}

@media (min-width: 768px) {
    .container {
        max-width: 720px;
    }
}

@media (min-width: 992px) {
    .container {
        max-width: 940px;
    }
}

@media (min-width: 1200px) {
    .container {
        max-width: 1140px;
    }
}
```

여기 너비의 스타일 규칙을 트리거하기 위해 수평 중단점을 정의하는 네 개의 미디어 쿼리가 있습니다. 예를 들어, `@media(min-width:768px)`는 브라우저에 `width` 속성이 컨테이너의 최대 너비를 `768px`보다 크거나 같은 뷰포트인 경우 `720px`로 만들도록 지시합니다. 이 속성은 뷰포트가 `992px`보다 크거나 같은 경우 `@media(min-width:992px)` 규칙으로 대체됩니다.

다음 스크린 샷을 살펴보기 바랍니다.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_002.jpg)

*그림 2.2*: `container` 클래스 사용하기

#### container-fluid

container의 다른 유형인 `container-fluid`는 두 가지 다른 방식으로 `container`와 다릅니다.

* 왼쪽 및 오른쪽 패딩 15픽셀을 제외하고 뷰 포트의 전체 너비를 차지합니다.
* 중단점과 관련이 없습니다.

`container-fluid`는 페이지가 모든 너비에 완전히 반응할 수 있도록 해서 보다 부드러운 전환을 제공합니다. 중단점에 대해 반응할 때, `container`는 레이아웃을 적절한 폭으로 스냅하여 조정을 하지만, `container-fluid`는 점진적으로 레이아웃을 변경합니다.

마크업의 유일한 차이점은 `container` 클래스가 컨테이너의 `div` 태그에 적용하는 것 대신 `container-fluid` 클래스가 적용된다는 것입니다. 다음 코드를 살펴보세요.

```html
<body>
    <div class="container-fluid">
        <h1>Help, I'm trapped in a container!</h1>
    </div>
    <div>
        <h1>I'm free!</h1>
    </div>
</body>
```

다음 스크린 샷을 살펴보세요.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_003.jpg)

*그림 2.3*: `container-fluid` 클래스의 사용

컨텐이너 요소는 브라우저의 가장자리에서 15픽셀 떨어진 곳에 위치합니다. 컨테이너를 사용할 때, 컨테이너에는 이미 하드 코딩이 된 너비가 정의되어 있습니다. 이 너비는 뷰포트를 기반으로 합니다. 예를 들어 폭 1200픽셀의 해상도에서 컨텡이너의 폭은 1140픽셀입니다. 1280픽셀의 해상도에서 컨테이너는 특정 중단점에 대해서만 응답하기 때문에 컨테이너는 1170픽셀의 너비로 유지가 됩니다. `container-fluid`를 사용할 때, 컨테이너의 너비는 동적입니다. 그 이유는 `container-fluid`는 모든 수평 변경에 대해 응답을 하고 너비를 `make-container` 믹스인의 패딩 값에만 기반하기 때문입니다. `container`는 특정 너비에서만 반응합니다. `container-fluid`는 특히 모바일을 우선으로 하는 애플리케이션을 만들 때, 모든 디스플레이 크기와 폼에서 작동해야 하는 페이지를 만들기 위해 취하는 접근 방식입니다.

`container`는 내용이 페이지의 정의된 영역 내에서 항상 표시되도록 합니다. 그러나 컨테이너 안에 콘텐츠를 두는 것은 어떨까요? 이것은 행이 시작하는 곳입니다.

> **참고**
>
> 박스 사이즈
>
> CSS에서는 모든 요소가 사각형 또는 박스로 표시됩니다. 각각의 박스에는 요소의 렌더링 방법을 정의하기 위해 여러 속성들이 연결되어 있습니다. 이것이 CSS Box Model입니다. `box-sizing` 속성은 박스 모델이 요소의 너비와 높이를 계산하는 방법을 정의합니다.
>
> CSS 박스 모델에서 `box-sizing`의 기본 값은 `content-box`입니다. `content-box` 속성은 해당 요소의 크기를 계산할 때, 요소의 내용만 포함합니다.
>
> 부트스트랩 4는 `box-sizing`의 기본 값을 `border-box`로 설정합니다. `border-box` 속성은 패딩과 테두리(border) 뿐만 아니라 요소의 높이와 너비를 계산할 때 그 안의 내용들도 포함됩니다. 여백은 계산에 포함하지 않습니다. 세 번째로 가능한 `box-sizing`의 값은 `padding-box`입니다. `padding-box` 속성은 이름에서 알 수 있듯이 요소의 크기를 계산할 때만 콘텐츠와 패딩을 사용합니다.

### 행(Rows)

`row`는 수평 그룹으로 처리되어야 하는 요소에 대한 선택을 정의하기 위해 사용합니다. 따라서 행은 세로 방향으로 콘텐츠를 쌓을 수 있습니다. 컨테이너 안의 컨테이너와 거의 유사하거나 또는 페이지의 섹션을 정의합니다. 행을 생성하는 것은 `row` 클래스를 원하는 요소에 적용하는 것으로 매우 간단합니다.

```html
<body>
    <div class="container">
        <h1>Help, I'm trapped in a container!</h1>
        <div class="row">
            <div>Section 1</div>
        </div>
        <div class="row">
            <div>Section 2</div>
        </div>
        <div class="row">
            <div>Section 3</div>
        </div>
    </div>
    <div>
        <h1>I'm free!</h1>
    </div>
</body>
```

다음 스크린 샷을 살펴보기 바랍니다.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_004.jpg)

*그림 2.4*: 행 사용하기

행의 진정한 힘은 열(column)과 함께 사용될 때 확실해집니다.

### 열(Columns)

열(컬럼)은 그리드 시스템에서 가장 중요한 부분입니다. 행은 컨테이너 안에 존재하고 있고 이 행들은 12개의 동일한 열로 나뉩니다. 핵심 세부 사항들을 살펴보기 전에 먼저 `MyPhoto`의 출력되는 크기 섹션을 만들기 위한 첫 단계를 수행하는 예제를 살펴보겠습니다. 12가지의 출력 크기가 제공됩니다. 이 크기를 가로로 나열해보겠습니다.

```html
<div class="container">
    <h1>Our Print Sizes</h1>
    <div class="row">
        <div class="col-sm-1">6x5</div>
        <div class="col-sm-1">8x10</div>
        <div class="col-sm-1">11x17</div>
        <div class="col-sm-1">12x18</div>
        <div class="col-sm-1">16x20</div>
        <div class="col-sm-1">18x24</div>
        <div class="col-sm-1">19x27</div>
        <div class="col-sm-1">20x30</div>
        <div class="col-sm-1">22x28</div>
        <div class="col-sm-1">24x36</div>
        <div class="col-sm-1">27x39</div>
        <div class="col-sm-1">27x40</div>
    </div>
</div>
```

평소처럼 컨테이너가 있습니다. 그 컨테이너 안에는 행이 있고, 그 행 안에는 `col-sm-1`과 함께 12 개의 개별 요소들이 있습니다. 이렇게 하면, 페이지에서 단일 행 안에 균등한 간격을 둔 요소 목록이 생성됩니다. 다음 스크린 샷을 살펴보세요.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_005.jpg)

*그림 2.5*: 출력 크기를 표시하기 위해 열(컬럼) 사용하기

`col-xs-1`을 뜯어보고 각 부분들을 개별적으로 설명하겠습니다.

* `col`: 이것은 요소를 열(컬럼)로써 사용하기를 원한다는 것을 의미합니다.
* `sm`: 이것은 544px 보다 크거나 같은 모든 뷰포트에 대한 참조입니다. 이 클래스는 544px 이상의 모든 뷰포트에 이 규칙을 적용한다는 의미입니다.
* `1`: 요소가 행의 한 열의 너비(행 너비의 1/12)를 차지함을 나타냅니다.

`col-sm-1`은 544px보다 큰 뷰포트를 참조하기 때문에 작은 뷰포트(예를 들어 핸드폰)는 스택뷰로 되돌아갑니다. 다음 스크린샷을 살펴보세요.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_006.jpg)

*그림 2.6*: 544px보다 작은 뷰포트는 `col-sm-1`을 사용할 때 스택 뷰로 되돌립니다.

행(컬럼)은 다섯 개의 별개의 중단점으로 나뉩니다.

* `col-xs-`: 이것은 544px 이하의 뷰포트 용입니다.(초소형)
* `col-sm-`: 이것은 544px 이상의 뷰포트 용입니다.(소형)
* `col-md-`: 이것은 768px 이상의 뷰포트 용입니다.(중간)
* `col-lg-`: 이것은 992px 이상의 뷰포트 용입니다.(대형)
* `col-xl-`: 이것은 1200px 이상의 뷰포트 용입니다.(초대형)

> **참고**
>
> 부트스트랩 3의 컬럼 중단점
>
> 부트스트랩 3에는 `col-xl`이 없습니다. 또한 네 개의 별개의 중단점은 다음과 같습니다.
> * `col-xs-`: 이것은 768px 이하의 뷰포트 용입니다.(초소형)
> * `col-sm-`: 이것은 768px 이상의 뷰포트 용입니다.(소형)
> * `col-md-`: 이것은 992px 이상의 뷰포트 용입니다.(중간)
> * `col-lg-`: 이것은 1200px 이상의 뷰포트 용입니다.(대형)

그런 다음 이 클래스에 요소가 포함해야 하는 열(컬럼) 수를 추가합니다. 출력 크기를 **Small**, **Medium**, **Large** 및 **Extra Large** 라는 이름으로 5개의 카테고리를 나눕니다. 아시다시피 행은 12개의 열로 나뉩다. 우리는 네 가지 출력 크기 범주를 가지고 있으므로, 열의 수를 요소의 수로 나눕니다. 이 수는 요소에서 다루기를 원하는 열의 수입니다. 그래서 우리는 `3`을 `col-sm-` 이라는 클래스 네임(classname)에 추가합니다.

```html
<div class="container">
    <h1>Our Print Sizes</h1>
    <div class="row">
        <div class="col-sm-3">Small</div>
        <div class="col-sm-3">Medium</div>
        <div class="col-sm-3">Large</div>
        <div class="col-sm-3">Extra Large</div>
    </div>
</div>
```

다음 스크린 샷을 살펴보기 바랍니다.

![](https://www.packtpub.com/graphics/9781783981120/graphics/image_02_007.jpg)

*그림 2.7*: 출력할 카테고리들을 그리드 시스템의 짝수 열로 나누었습니다.

그러나 다시 한 번 작은 뷰포트에서 요소들을 쌓을 것입니다. 즉, 요소가 다른 요소 위에 겹쳐서 나타나게 될 것입니다. 그러나 우리가 이것을 원한다면 어떻게 될까요? 뷰포트 크기가 변경될 때 요소가 다른 수의 열을 차지하도록 하려면 어떻게 해야 할까요? 잘만 하면 부트스트랩을 사용해서 모든 중단점의 열 너비를 정의할 수 있으며, 적용할 규칙을 결정할 수 있습니다. 다음을 시도해보세요.

```html
<div class="container">
    <h1>Our Print Sizes</h1>
    <div class="row">
        <div class="col-xs-6 col-sm-3">Small</div>
        <div class="col-xs-6 col-sm-3">Medium</div>
        <div class="col-xs-6 col-sm-3">Large</div>
        <div class="col-xs-6 col-sm-3">Extra Large</div>
    </div>
</div>
```

우리는 `col-sm-3`을 얻어왔지만, `col-xs-6`을 포함시켰습니다. 즉, 너비가 `544px` 미만인 뷰포트의 경우 각 요소가 `6`개의 을 차지해야만 합니다. 그러면 첫 번째의 두 요소가 한 줄에 표시되고 그 중 두 줄은 그 아래에 표시됩니다.

`544px` 이상의 뷰포트에서 카테고리는 하나의 가로 행으로 나타납니다(이전에 언급했듯이, 이것은 부트스트랩 3에서과감한 변경이며, 코드를 사ㅇ하는 이전 버전의 부트스트랩에서는 `768px` 이상일 때 카테고리가 뷰포트의 가로 행에 나타납니다. 다음 스크린샷을 보기 바랍니다.

![](/assets/image_02_008.jpg)

*그림 2.8*: 544px 이상의 해성도에서의 출력 크기

544px 미만의 뷰포트에서는 카테고리가 두 행으로 분할됩니다. 다음 스크린 샷을 살펴보세요.

![](/assets/image_02_009.jpg)

*그림 2.9*: 544px 이하의 해상도에서의 출력 크기

### 중첩(Nesting)

그리드 시스템은 행을 열로 가로로 분할할 뿐만 아니라 중첩된 행을 지원하여 열을 세로로 분할할 수도 있습니다. 이러한 중첩된 행 자체는 상위 열에 의해 제공된 공간 내에서 12개의 열로 나뉩니다. 행 시작을 달성하기위해 마크업 측면에서 해야할 특별한 것은 없습니다. 이를 달성하기위해 필요한 것은 요소를 적절히 중첩시키고 행과 열 클래스를 적용하는 것입니다.

출력 크기와 관련해서 카테고리를 구성해 보겠습니다. 4가지 크기의 카테고리로 똑같이 나뉘는 12가지의 크기 옵션이 필요합니다. 각 범주에는 각 출력 크기가 그리드에서 하나의 열을 차지하는 한 개의 행 요소를 포함합니다. 다음을 시도해보세요.

```html
<div class="container">
    <h1>Our Print Sizes</h1>
    <div class="row">
        <div class="col-xs-6 col-sm-3">
            <h5>Small</h5>
            <div class="row">
                <div class="col-sm-4">6x5</div>
                <div class="col-sm-4">8x10</div>
                <div class="col-sm-4">11x17</div>
            </div>
        </div>
        <div class="col-xs-6 col-sm-3">
            <h5>Medium</h5>
            <div class="row">
                <div class="col-sm-4">12x18</div>
                <div class="col-sm-4">16x20</div>
                <div class="col-sm-4">18x24</div>
            </div>
        </div>
        <div class="col-xs-6 col-sm-3">
            <h5>Large</h5>
            <div class="row">
                <div class="col-sm-4">19x27</div>
                <div class="col-sm-4">20x30</div>
                <div class="col-sm-4">22x28</div>
            </div>
        </div>
        <div class="col-xs-6 col-sm-3">
            <h5>Extra Large</h5>
            <div class="row">
                <div class="col-sm-4">24x36</div>
                <div class="col-sm-4">27x39</div>
                <div class="col-sm-4">27x40</div>
            </div>
        </div>
    </div>
</div>
```

다음의 스크린샷을 보기 바랍니다.

![](/assets/image_02_010.jpg)

*그림 2.10*: 중첩을 사용한 출력 크기

카테고리 열 안에 중첩된 행이 잇습니다. `col-sm-4`를 사용하여 각 행을 544px의 너비보다 크거나 같은 뷰표트일 경우에 대해 3개의 동일한 열로 분할하여 출력 크기를 표시했습니다. 이처럼 간단합니다. 일반적으로 중첩된 행에 정의한 열의 총 합이 할당된 12개의 열초과하지 않도록 하는 것이 좋습니다. 부트스트랩은 12개의 열을 가정하여 그에 따라 너비를 적용합니다. 12개의 열을 초과하면 불일치하게 되거나 또는 예상하지 못한 열 너비 오류가 발생할 수 있습니다. 그러나 경우에 따라 특정 해상도에서 다른 행에 열을 적용할 수도 있습니다. 예를 들어, 열의 텍스트의 내용이 특정 해상도에서는 약간 겹칠 수도 있습니다.

이러한 경우에는 작은 해상도로 특정 열을 다른 라인으로 보내려 합니다. 이를 위해서 `col-md-*` 클래스를 추가하고 새 줄이 필요한 열을 544px의 `col-sm-12` 클래스에 제공합니다. **Large** 카테고리의 세 번째 크기를 자체 라인에 적용하고 모든 **Extra Large** 크기를 별도의 라인에 강제로 적용해보겠습니다. 다음을 시도해보세요.

```html
<div class="col-xs-6 col-sm-3">
    <h5>Large</h5>
    <div class="row">
        <div class="col-sm-4">19x27</div>
        <div class="col-sm-4">20x30</div>
        <div class="col-sm-12 col-md-4">22x28</div>
    </div>
</div>
<div class="col-xs-6 col-sm-3">
    <h5>Extra Large</h5>
    <div class="row">
        <div class="col-sm-12 col-md-4">24x36</div>
        <div class="col-sm-12 col-md-4">27x39</div>
        <div class="col-sm-12 col-md-4">27x40</div>
    </div>
</div>
```

다음 스크린샷을 살펴보기 바랍니다.

![](/assets/image_02_011.jpg)

**그림 2.11**: "Extra Large" 카테고리가 있는 출력 크기가 544px 미반인 뷰포트에 대해서 별도의 행에 적용됩니다.

멋지고 깔끔합니다. 주의를 기울였다면, 기본 동작이므로 요소에 별도의 줄을 표시하기 위해 **Medium** 이하의 해상도를 실제로 정의할 필요가 없다는 것을 알았을 것입니다. `xs`와 같은 해상도와 다른 동작을 원한다면 따로 정의할 필요가 있습니다. 그래서 트릭을 해야 합니다.

```html
<div class="col-xs-6 col-sm-3">
    <h5>Large</h5>
    <div class="row">
        <div class="col-sm-4">19x27</div>
        <div class="col-sm-4">20x30</div>
        <div class="col-md-4">22x28</div>
    </div>
</div>
<div class="col-xs-6 col-sm-3">
    <h5>Extra Large</h5>
    <div class="row">
        <div class="col-md-4">24x36</div>
        <div class="col-md-4">27x39</div>
        <div class="col-md-4">27x40</div>
    </div>
</div>
```

> **참고**
>
> Column과 Flexbox
> 
> 그리드 시스템에서 Flexbox를 사용할 수 있는 경우, 앞에서 설명한대로 `$enable-flex`를 `true`로 설정하여 부트스트랩이 열 크기를 자동으로 동일하게 설정할 수 있도록 할 수 있습니다. 이렇게 하려면 `col-*`를 사용하세요. 여기서 `*`은 중단점입니다. 예제에서는 `col-xs`입니다. 한 행에 `col-xs` 클래스와 함께 있는 두 형제 요소가 주어지면 두 열 모두 자동으로 동일한 너비가 부여됩니다.

그리드 시스템을 사용하면 마크업에서 정렬 순서와 관계 없이 열을 정렬할 수 있습니다. 부트스트랩 4는 `pull-*-*`과 `push-*-**` 클래스를 통해 이 작업을 할 수 있습니다. 이 클래스는 부트스트랩 3에서 `col-*-pull-*`과 `col-*-push-*`의 형태를 취했습니다.








