# 8장. 웹사이트 최적화

**웹사이트 최적화**는 웹사이트 호스팅과 관련된 비용을 줄이면서 웹사이트의 사용자 경험과 가시성을 향상시키는 활동과 프로세스를 의미합니다. Andrew B. King은 자신의 저서 **웹사이트 최적화(Website Optimization)**에서 이 개념을 **"어떻게 하면 웹사이트를 더 잘 만들 수 있을까요?"**라는 질문과 함께 간략히 요약했습니다. 이처럼 주제는 전체 서적의 유일한 주제였으며, 한개의 챕터는 빙산의 일각일 뿐입니다. 이 주제는 서버측 최적화, 검색 엔진 최적화, 클릭당 비용 최적화 및 클라이언트측 최적화에 이르는 다양한 측면 중 하나입니다. 이 장에서는 마지막 부분에 대한 것만 논의 할 것입니다. 즉, 우리는 `MyPhoto`의 로드 및 렌더링 시간을 향상시킬 것입니다. 특히 이 장은 다음의 것과 관련이 있습니다.

* `MyPhoto`의 `index.html`의 로딩 시칸 향상시키기
* 이 목적을 달성하기 위한 태스크 자동화

이 장의 마지막 부분에서는 클라이언트측 최적화의 핵심 기술을 이해하게 될 것입니다. `MyPhoto` 컨텍스트 내에서 다음과 같은 방법을 배우게 될 것입니다.

* 웹페이지를 렌더링하는 데 필요한 전체 HTTP 요청 수를 줄입니다.
* 사용하지 않는 CSS 규칙을 자동으로 제거합니다.
* 자바스크립트 및 CSS 파일을 더 작게 만듭니다(보통 minification이라고 합니다).
* 다양한 최적화 작업의 자동화
* CSS 규칙 최적화

## CSS 최적화

압축, 최소화 및 파일 연결을 고려하기 전에 타사 도구를 사용하지 않고도 기존의 스타일시트를 단순화 하고 최적화 할 수 있는 방법에 대해 생각해봐야 합니다. 물론, 우리는 최적의 스타일시트를 만들기 위해 노력해야 했으며, 이런면에서 그래왔습니다. 그러나 우리의 스타일시트는 여전히 개선의 여지가 있습니다. 이러한 개선 사항 중 일부는 장의 의도된 목적을 훼손했기 때문에 이전 장에서 의도한대로 무시되었습니다. 그러나 이 장에서는 웹 페이지의 클라이언트 측 코드를 최적화 하는 것과 관련되어 있으므로 스타일시트를 작게 유지하고 규칙을 짧게 유지하는 데 도움이 되는 일반적인 팁과 사례에 대해 이야기 할 것입니다. 우리는 이러한 팁과 관행을 차례대로 다룰 것입니다.

### 인라인 스타일

이 장을 읽고 난 후에 한 가지만 기억할 것이 있는데 인라인 스타일은 좋지 않다는 것입니다. 가능하다면 사용하지 마세요. 웹사이트가 성장함에 따라 웹사이트를 유지보수할 수 없도록 만들 뿐만 아니라 반복해서 동일한 규칙을 적용해야 하므로 용량만을 차지합니다. **Gallery** 섹션에 대해 다음의 마크업을 살펴보시기 바랍니다.

```html
<div class="carousel-inner" role="listbox">
    <div style="height: 400px" class="carousel-item active">
        <img data-modal-picture="#carouselModal" src="images/brazil.png">
        <div class="carousel-caption">
            Brazil
        </div>
    </div>
    <div style="height: 400px" class="carousel-item">
        <img data-modal-picture="#carouselModal" src="images/datsun.png">
        <div class="carousel-caption">
            Datsun 260Z
        </div>
    </div>
    <div style="height: 400px" class="carousel-item">
        <img data-modal-picture="#carouselModal" src="images/skydive.png">
        <div class="carousel-caption">
            Skydive
        </div>
    </div>
</div>
```

갤러리 아이템의 높이를 정의하는 규칙인 `style="height: 400px"`이 세 개의 갤러리 항목에 대해 매번 반목되는 점에 유의하기 바랍니다. 이는 추가 이미지 각각에 대해 21자(또는 문서가 UTF-8일 경우를 가정하면 21바이트)입니다. 3 x 21은 63바이트가 됩니다. 갤러리에 추가하려는 새로운 이미지에 대해 21바이트씩 추가됩니다. 갤러리의 이미지 `height`를 업데이트 하려면 모든 단일 이미지의 `style` 속성을 수동으로 업데이트 해야 합니다. 해결책은 인라인 스타일을 적절한 클래스로 바꾸는 것입니다. 이제 모든 캐러셀 이미지에 적용할 수 있는 `img` 클래스를 정의해보겠습니다.

```css
.carousel-item { 
    height: 400px; 
}
```

이제 스타일 규칙을 제거하겠습니다.

```html
<div class="carousel-inner" role="listbox">
    <div class="carousel-item active">
        <img data-modal-picture="#carouselModal" src="images/brazil.png">
        <div class="carousel-caption">
            Brazil
        </div>
    </div>
    <div class="carousel-item">
        <img data-modal-picture="#carouselModal" src="images/datsun.png">
        <div class="carousel-caption">
            Datsun 260Z
        </div>
    </div>
    <div class="carousel-item">
        <img data-modal-picture="#carouselModal" src="images/skydive.png">
        <div class="carousel-caption">
            Skydive
        </div>
    </div>
</div>
```

좋습니다. CSS를 유지보수하기가 더 쉬울 뿐만 아니라 웹 사이트에서 29 바이트가 줄어들었습니다(원래 인라인 스타일은 63바이트가 필요했지만 새로운 클래스 정의는 34바이트만 필요함). 그렇습니다. 특히  초고속 인터넷의 세계에서는 특별히 대단해 보이진 않을 것입니다. 하지만 귀하의 웹사이트는 성장할 것이고 모든 용량들도 늘어날 것임을 기억하세요.

HTML 문서에는 여러가지 인라인 스타일이 있습니다. 다음 섹션으로 넘어가기 전에 먼저 수정하세요.

### 긴 식별자와 클래스 이름

문자열이 길수록 파일도 커집니다. 생각할 필요도 없는 이유입니다. 따라서 긴 식별자와 클래스 이름은 당연히 웹페이지의 크기를 증가시킵니다. 물론 매우 짧은 클래스나 식별자 이름을 쓸 수 있지만 이것은 의미가 부족한 경향이 있기 때문에 페이지를 유지보수하기가 더 어렵습니다. 따라서 길이와 표현력 사이의 이상적인 균형을 위해 노력해야 합니다(이 장의 뒷 부분에 있는 두 가지 이점을 모두 제공하는 편리한 도구를 제공할 것입니다). 물론, 식별자를 줄이는 것보다 훨씬 더 좋은 것은 식별자를 모두 제거하는 것입니다. 이러한 제거를 위한 편리한 기술 중 하나는 계층적 선택을 사용하는 것입니다. 우리 `events`에서의 페이지 매김 코드를 들 수 있습니다. 예를 들어 다음과 같이 패이지 매김 로직에서는 `services-event-content`라는 식별자를 사용합니다.

```javascript
$('#services-events-pagination').bootpag({
    total: 10
}).on("page", function (event, num) {
    $('#services-events-content div').hide();

    var current_page = '#page-' + num;
    $(current_page).show();
});
```

`services` 내용을 나타내기 위해 우리의 식별자의 이름을 `services`, `events`, `content` 세 부분으로 나누었습니다. 마크업은 다음과 같습니다.

```html
<div id="services-events-content">
    <div id="page-1">
        <h3>My Sample Event #1</h3>
        ...
    </div>
</div>
```

**Events** 섹션의 두 가지 특성을 관찰하여 이 식별자를 모두 제거해 봅시다.

* `services-events-content`는 `id services-events`를 가진 `div`의 간접적인 자손입니다. 이 `id`는 제거할 수 없습니다. 메뉴가 작동하는 데 필요하기 때문입니다.
* `id services-events-content`를 가진 요소는 그 자체가 `div`입니다. `id`를 제거하려면 `div` 전체를 제거해야 합니다.

따라서 숨기려는 페이지를 선택하기 위해 두번째 식별자가 필요하지 않습니다. 대신 우리가 해야 할 일은 `id services-events`가 할당된 `div` 안의 `div`를 선택하는 것입니다. 이것을 CSS 셀렉터로 어떻게 표시해야 할까요? 쉽습니다. `#services-events div div div`를 사용합니다. 그리고 우리의 페이지매김 로직은 다음과 같이 업데이트 될 것입니다.

```javascript
$('#services-events-pagination').bootpag({
    total: 10
}).on("page", function (event, num) {
    $('#services-events div div div').hide();
    var current_page = '#page-' + num;
    $(current_page).show();
});
```

저장하고 새로고침 합니다. 페이지를 클릭하면 페이지 매긴 콘트롤이 사라집니다. 이제 `id services-events`를 사용한 요소로부터 아래로 두 개의 `div` 요소를 가지고 있는 `div` 요소가 숨기기 때문입니다. 상위 요소 외부의 페이지 매긴 콘트롤 `div`로 이동합니다. 이제 마크업은 다음과 같이 보일 것입니다.

```html
<div class="tab-content bg-myphoto-light">
    <div role="tabpanel" class="tab-pane active" id="services-events">
        <div class="container">
            <div class="row" style="margin: 1em;">
                <div id="page-1">
                    <h3>My Sample Event #1</h3>
                    ...
                    <h3>My Sample Event #2</h3>
                    ...
                </div>
                <div id="page-2">
                    <h3>My Sample Event #3</h3>
                    ...
                </div>
            </div>
            <div id="services-events-pagination"></div>
        </div>
    </div>
</div>
```

저장하고 새로고침 합니다. 훨씬 낫습니다. 마지막으로 `myphoto.css`를 업데이트 합니다. 다음 코드를 따라하세요.

```css
#services-events-content div {
    display: none;
}

#services-events-content div img {
    margin-top: 0.5em;
    margin-right: 1em;
}

#services-events-content {
    height: 15em;
    overflow-y: scroll;
}
```

다음의 코드로 교체합니다.

```css
#services-events div div div {
    display: none;
}

#services-events div div div img {
    margin-top: 0.5em;
    margin-right: 1em;
}

#services-events div div div {
    height: 15em;
    overflow-y: scroll;
}
```

스타일시트를 간소화 하였고 처리 과정에서 몇 바이트 정도 절약하였습니다.

### 속기-약식(Shorthand) 규칙

Mozilla Developer Network(2015년 11월 기준으로 약식속성. [https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties))에 의하면 약식 속성은 다음과 같습니다.

> **Mozilla Developer Network, 2015**
>
> 다른 CSS 속성의 값을 동시에 설정할 수 있는 CSS 약식 속성을 사용하여 웹 개발자는 보다 간결하고 자주 읽을 수 있는 스타일 시트를 작성하여 시간과 노력을 절약할 수 있습니다."

엄밀히 말하면, 우리는 일반적인 손으로 쓰는 규칙을 사용해서는 안됩니다. 가능하다면 속기 규칙을 선호하는 것이 좋습니다. 귀중한 바이트를 절약하는 이점 이외에도 속기 규칙은 스타일 시트의 유지보수성을 높여줍니다. 예를 들어 `border: 20px dotted #FFF`는 다음의 세 가지의 별도 규칙과 동일합니다.

```css
border-style: dotted;
border-width: 20px;
border-color: #FFF; 
```

### 셀렉터 그룹화

셀렉터를 그룹으로 구성하면 틀림없이 용량을 절약할 수 있습니다. `myphoto.css`의 80~93번 라인을 보기 바랍니다.

```css
.navbar-myphoto .dropdown-menu>a:hover {
    color: gray;
    background-color: #504747;
}

.navbar-myphoto .dropdown-menu>a:focus {
    color: gray;
    background-color: #504747;
}

.navbar-myphoto .dropdown-menu>.active>a:focus {
    color: gray;
    background-color: #504747;
}
```

세 개의 셀렉터 각각에 동일한 선언이 어떤 식으로 포함이 되어 있는지를 주목하세요. 즉 `color`과 `background-color` 속성은 각 셀렉터에 대해 동일한 값으로 설정되고 있습니다. 이러한 선언을 반복하지 않으려면 코드를 그룹화 해야 합니다(코드를 274자에서 181자로 줄일 수 있습니다).

```css
.navbar-myphoto .dropdown-menu>a:hover,
.navbar-myphoto .dropdown-menu>a:focus,
.navbar-myphoto .dropdown-menu>.active>a:focus {
    color: gray;
    background-color: #504747;
}
```

와!! 우리는 93바이트나 절약했습니다(UTF-8 인코딩이라고 가정했을 때).

### 렌더링 시간

스타일 룰을 최적화 할 때 바이트 수만 고려하면 안됩니다. 사실 이것은 웹 페이지의 렌더링 시간에 부차적인 것입니다. CSS 규칙은 브라우저에서 페이지를 렌더링하는 데 필요한 작업량에 영향을 줍니다. 따라서 일부 규칙은 다른 규칙들에 비해 렌덜이 비용이 올라갑니다. 예를 들어, 요소의 색상을 변경하는 것은 여백을 변경하는 것 보다 비용이 적게 듭니다. 그 이유는 색상을 변경할 때 브라우저가 새로운 픽셀을 그리기만 하면 되기 때문입니다. 드로잉 자체가 결코 값 싼 작업이 아니기 때문에 요소의 여백을 변경하는 데에는 훨씬 많은 비용이 듭니다. 브라우저는 페이지 레이아웃을 다시 계산하고 변경 사항을 그려야 합니다. 페이지의 렌더링 시간을 최적화 하는 것은 복잡한 주제이며 이 책의 범위를 벗어납니다.

그러나 [http://csstriggers.com/](http://csstriggers.com/)을 살펴보는 것이 좋습니다. 이 사이트에서는 주어진 CSS 속성을 업데이트할 때 소요되는 비용에 대한 간략한 개요를 제공합니다.

> **참고**
>
> **Udacity**는 브라우저 렌더링 최적화에 대한 무료 온라인 과정을 제공합니다. 자세한 내용은 [https://www.udacity.com/](https://www.udacity.com/) 사이트로 이동하세요. 우리는 코스를 충분히 추천할 수는 없습니다.

## CSS와 자바스크립트 압축

`MyPhoto` 스타일 규칙을 가능한한 컴팩트하고 효율적이며, 유지보수가 가능하도록 개선하고 난 다음으로는 축소를 할 차례입니다. 축소화 하는 것은 파일에 포함된 실제의 정보를 변경하지 않고 파일에서 중복 문자를 제거하는 프로세스입니다. 즉, `myphoto.css` 파일ㅇ르 축소하면 전체적인 크기가 줄어들고 실제 CSS 스타일 규칙은 그대로 유지됩니다. 공백 문자를 제거하면, CSS가 사실상 읽을 수 없고 유지보수가 불가능하다는 명백한 결과가 나타납니다. 따라서 축소된 스타일 시트는 개발중이 아닌 페이지를 제공할 때(프로덕션을 제공하는 동안)에만 사용해야 합니다.

명백한 것은 수동으로 스타일시트를 축소하는 일은 엄청나게 시간이 걸리는(따라서 무의미한) 작업이 될 것입니다. 우리를 위해 일해줄 많은 도구들이 있습니다. 그러나 도구 중 하느는 `npm minifier`입니다. 자세한 내용은 [https://www.npmjs.com/package/minifier](https://www.npmjs.com/package/minifier)을 방문하세요.

계속해서 설치해보겠습니다.

```bash
sudo npm install -g minifier
```

설치가 완료되면 다음 명령을 입력하여 스타일 시트를 축소할 수 있습니다.

```bash
minify path-to-myphoto.css
```

여기서 `path-to-myphoto.css`는 `MyPhoto` 스타일 시트의 경로를 나타냅니다. 명령을 실행하세요. 압축이 완료되면 새로운 CSS 파일(`myphoto.min.css`)은 `myphoto.css` 파일이 들어 있는 디렉토리 내에 생성됩니다. 새 파일은 3,358 바이트이어야 합니다. 원래의 `myphoto.css` 파일은 3,945 바이트 입니다. 스타일 시트를 축소하여 바이트 수를 약 15% 정도 줄였습니다.

HTML 문서의 `head`를 업데이트 하여 새롭게 축소된 스타일 시트를 참조하도록 합니다.

```html
<link rel="stylesheet" href="styles/myphoto.min.css" />
```

CSS 축소 뿐만 아니라 minifier는 자바스크립트 파일도 축소해줍니다. 예를 들어 `alert.js` 파일을 축소하려면 다음을 입력하세요.

```bash
minify path-to-alert.js
```

다시 한번 축소가 완료되면 **Minification complete** 메시지를 볼 수 있습니다. 이전과 마찬가지로 `alert.js` 파일이 포함된 디렉토리 내에 새로운 파일(`alert.min.js`)이 생성됩니다.

## Grunt 소개

이전 섹션에서 사용한 minifier는 스타일 시트 및 자바스크립트 파일의 크기를 크게 줄여주었고 `MyPhoto`를 렌더링 하기 위해 필요한 전체의 리퀘스트 수를 줄이는데에도 도움이 되었습니다. 그러나 사용할 때 한 가지 단점이 있습니다. 개발 중에 CSS나 자바스크립트 코드를 변경할 때 마다 이 도구를 다시 실행해야 합니다. 이것은 굉장히 피곤한 일입니다(minifier를 실행하는 것을 잊어버린 상태에서 실행했다고 생각해서 변경 사항이 표시되지 않는 경우를 상상해보세요. 건망증과는 반대로 코드를 비난할 가능성이 높습니다). 따라서 축소과정을 연결할 수 있다면 좋지 않을까요? 소스코드를 변경할 때 마다 자동으로 파일이 생기는건 어떨까요?

자바스크립트 태스크 런너(JavaScript Task Runner[http://gruntjs.com/](http://gruntjs.com/)) **Grunt**를 만나봅시다. Grunt는 이름에서 알 수 있듯이 모든 작업들을 자동으로 실행할 수 있는 도구입니다. Grunt는 코딩하는 동안 기다릴 수 있고 소스코드 파일(CSS, HTML 또는 자바스크립트)를 픽업한 다음 변경사항을 저장할 때마다 사전에 구성된 일련의 작업을 실행할 수도 있습니다. 이 방법을 사용하면 더 이상 변경 사항을 적용하기 위한 일련의 명령들을 수동으로 실행할 필요가 없습니다.

계속해서 Grunt를 설치해보겠습니다.

```bash
npm install grunt --save-dev
```

`MyPhoto`를 사용하여 실행을 시작하려면 먼저 Grunt에게 알려야 합니다.

* 실행할 작업, 즉 입력(입력이 `MyPhoto` 파일입니다)과 출력을 저장하는 위치에 대해 설명합니다.
* 작업들을 실행하는데 사용되는 소프트웨어를 알아봅니다.
* 필요한 경우 작업을 호출할 수 있도록 작업의 이름을 지정하는 방법을 알아봅니다.

이를 염두에 두고 우리는 프로젝트 루트에 `Gruntfile.js`라는 새로운 자바스크립트 파일(UTF-8 인코딩을 가정)을 만듭니다. `package.json`이라는 JSON 파일도 프로젝트 루트에 만들어 두어야 합니다. 프로젝트 폴더는 다음과 같은 구조를 가져야 합니다(추가로 src를 어떻게 만들고 소스 코드와 개발 애셋을 어떻게 옮겼는지 주의하세요).

```
src 
|__bower_components
|__images
|__js
|__styles
|__index.html
Gruntfile.js
package.json
```

새롭게 만들어진 `Gruntfile.js`를 열고 다음 기능 정의를 추가합니다.

```javascript
module.exports = function (grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json")
    });
};
```

앞의 코드는 자명합니다. `name` 속성을 프로젝트 이름을 참조하고 `version`은 프로젝트 버전을 나타내며, `devDependencies`는 필요한 모든 종속성을 참조합니다(잠시 후 추가할 예정입니다).

이제 Grunt를 사용하여 시작할 준비가 되었습니다.

### Grunt를 사용한 압축과 연결

Grunt가 할 수 있는 첫 번째 일은 파일을 압축하는 것입니다. 이미 `minifier`가 설치되어 있지만, Grunt를 사용하여 한 번에 여러 작업(예를 들어 압축 작업)을 자동으로 실행할 수 있습니다. 이렇게 하려면 `grunt-contrib-cssmin` 패키지(압축 및 연결을 수행하는 Grunt 패키지)를 설치해야 합니다. 자세한 내용은 [https://github.com/gruntjs/grunt-contrib-cssmin](https://github.com/gruntjs/grunt-contrib-cssmin)을 방문하세요.

```bash
npm install grunt-contrib-cssmin --save-dev
```

설치가 끝나면 `package.json`을 검사하세요. 새로 설치된 패키지를 개발 의존성으로 포함되도록 새롭게 설치된 페키지를 추가하기 위해 수정하는 방법을 살펴보세요.

```javascript
{
    "name": "MyPhoto",
    "version": "0.1.0",
    "devDependencies": {
        "grunt": "^0.4.5",
        "grunt-contrib-cssmin": "^0.14.0"
    }
}
```

Grunt에게 플러그인에 대해 알려야 합니다. 이렇게 하기 위해서는 `Gruntfile.js`의 기능 정의 안에 다음의 행을 삽입합니다.

```javascript
grunt.loadNpmTasks("grunt-contrib-cssmin");
```

`Gruntfile.js`는 다음과 같이 보일 것입니다.

```javascript
module.exports = function (grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json")
    });
    grunt.loadNpmTasks("grunt-contrib-cssmin");
};
```

따라서 우리는 여전히 많은 일을 할 수 없습니다. 앞의 코드는 Grunt가 `grunt-contrib-cssmin` 패키지를 인식하도록 합니다(즉, Grunt가 이 패키지를 로드할 것을 알립니다). 패키지를 사용하여 파일을 축소할 수 있으려면 Grunt 작업을 만들어야 합니다. 우리는 이 작업을 `cssmin`이라고 부를 필요가 있습니다.

```javascript
module.exports = function (grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json"),
        "cssmin": {
            "target": {
                "files": {
                    "src/styles/myphoto.min.css": ["src/styles/*.css"]
                }
            }
        }
    });
    grunt.loadNpmTasks("grunt-contrib-cssmin");
};
```

한 번에 많은 코드가 들어갔습니다. 무슨일이 벌어진 것일까요. 우리는 `cssmin` 이라는 새로운 작업을 등록했습니다. 그런 다음 대상, 즉 Grunt가 이 작업에 사용해야 하는 입력 파일을 지정했습니다. 특히 다음과 같이 표기했습니다.

```javascript
"src/styles/myphoto.min.css": ["src/styles/*.css"]
```

여기서 속성 이름은 출력을 나타내는 것으로 해석되고 속성 값은 입력을 나타냅니다. 그러므로 우리는 본질적으로 다음의 내용을 따르고 있습니다.

**"`myphoto.min.css`를 생성하려면 `src/styles` 디렉토리 내의 파일 확장자가 `css`로 끝나는 파일을 사용하세요."**

다음을 입력하여 Grunt 태스크를 실행하세요.

```bash
grunt cssmin
```

완료되면 다음 행을 따라 출력이 표시됩니다.

![](/assets/1967_08_01.jpg)

*그림 8.1*: cssmin을 실행한 후 콘솔에서의 출력 결과

첫 번째 줄은 새로운 출력 파일(`myphoto.min.css`)이 생상되었으며, 크기가 **3.25KB**임을 나타냅니다(원래 **4.99KB**). 두 번째 줄은 자명합니다. 즉 태스크가 오류 없이 성공적으로 실행됩니다.

`grunt-contrib-cssmin`을 사용하는 방법을 알았으니 이제는 멋진 엑스트라에 대한 문서를 살펴보기 바랍니다.

## 태스크 실행 자동화

Grunt를 사용하여 스타일 시트를 압축하는 방법을 알았으니 이제는 자동화에 집중할 차례입니다. 즉, 소스 파일을 변경하지마자 Grunt 압축 작업을 자동으로 실행하는 방법입니다. 이를 위해서 `grunt-contrib-watch`([https://github.com/gruntjs/grunt-contrib-watch](https://github.com/gruntjs/grunt-contrib-watch))라고 하는 두 번째 Grunt 패키지에 대해 배웁니다. `contrib-css-min`과 마찬가지로 이 패키지는 npm을 사용하여 설치할 수 있습니다.

```bash
npm install grunt-contrib-watch --save-dev
```

`package.json`을 열고 `grunt-contrib-watch`가 의존성에 추가되었는지를 확인합니다.

```javascript
{ 
    "name": "MyPhoto", 
    "version": "0.1.0", 
    "devDependencies": { 
        "grunt": "^0.4.5", 
        "grunt-contrib-cssmin": "^0.14.0", 
        "grunt-contrib-watch": "^0.6.1" 
    } 
} 
```

다음으로 `Gruntfile.js`의 Grunt에서 `grunt.loadNpmTasks('grunt-contrib-watch')`를 추가하여 새로운 패키지에 대해 알려줍니다.  또한 `watch`라는 새로운 빈 속성을 추가하여 `watch`에 대한 작업을 정의해야 합니다.

```javascript
module.exports = function (grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json"),
        "cssmin": {
            "target": {
                "files": {
                    "src/styles/myphoto.min.css": ["src/styles/*.css", "src/styles!*.min.css"]
                }
            }
        },
        "watch": {}
    });
    grunt.loadNpmTasks("grunt-contrib-cssmin");
    grunt.loadNpmTasks("grunt-contrib-watch");
};
```

Grunt가 새로 설치된 `watch` 패키지를 로드했으므로 `grunt watch` 명령을 실행할 수 있습니다. 그러나 아직 작업을 구성하지 않았으므로 Grunt는 다음과 같이 종료될 것입니다.

![](/assets/image_08_002.jpg)

*그림 8.2*: watch 태스크를 실행한 후의 콘솔 출력

가장 먼저 해야 할 일은 우리의 `watch` 태스크가 실제로 어떠한 파일을 "감시"할 것인지를 알려주는 것입니다. `grunt-contrib-cssmin`에서 했던 것 처럼 `files` 속성을 설정하여 이 작업을 수행합니다.

```javascript
"watch": {
    "target": {
        "files": ["src/styles/myphoto.css"],
    }
}
```

이것은 `watch` 태스크가 `src/styles` 폴더에 있는 `myphoto.css`를 입력으로 사용하도록 지시합니다(`myphoto.css`의 변경 사항만 감시합니다).

> **참고**
>
> 실제로 `styles/` 안에 있는 모든 CSS 파일들을 감시하고 싶을 것입니다. 그러나 간단하게 하기 위해서 `myphoto.css`만 보도록 합니다.

다시 `grunt watch`를 실행합니다. 처음으로 명령을 실행했던 것과는 달리 작업이 종료되지 않아야 합니다. 대신 **Waiting...** 메시지와 함께 멈춰 있어야 하고 `myphoto.css` 파일에 공백 제거와 같은 사소한 변경을 하세요. 그런 다음 변경 사항을 저장하고 터미널에서의 출력이 어떻게 되는지를 확인하세요.

![](/assets/image_08_003.jpg)

*그림 8.3*: watch 태스크를 실행한 후의 콘솔 출력

이제 `watch` 태스크는 `src/styles` 내의 모든 스타일 시트에 대한 파일 변경 사항을 성공적으로 수신합니다. 다음 단계는 이 기능을 잘 활용하는 것입니다. 즉, 이전 섹션에서 작성한 축소 작업을 실행하기 위해 감시 작업을 수행해야 합니다. 이렇게 하려면 `target`에 `tasks` 속성을 추가하기만 하면 됩니다.

```javascript
"watch": { 
    "target": { 
        "files": ["src/styles/myphoto.css"], 
        "tasks": ["cssmin"] 
    } 
} 
```

다시 한 번 `grunt watch`를 실행합니다. 이번에는 `myphoto.css` 스타일 시트에 시각적인 변화를 만듭니다. 예를 들어 `body {backgroun-color: red;}`와 같은 명백한 규칙을 추가합니다. 변경사항을 저장하면 `watch` 태스크가 `cssmin`  태스크를 어떻게 실행하는지를 확인하기 바랍니다.

![](/assets/image_08_004.jpg)

*그림 8.4*: 감시 중인 스타일 시트를 변경 한 후 콘솔의 출력

브라우저에서 페이지를 새로 고치고 변경한 사항을 확인하세요. 스타일 시트를 변경할 때마다 수동으로 `minifier`를 실행할 필요가 없습니다.


https://www.packtpub.com/mapt/book/web_development/9781783981120/8/ch08lvl1sec50/Stripping+our+website+of+unused+CSS