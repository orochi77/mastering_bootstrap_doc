# 6장. 플러그인 커스터마이징

지금까지 부트스트랩이 제공하는 모든 것을 사용하고 부트스트랩의 테마와 컴포넌트를 커스터마이징 하며, 그 과정에서 jQuery 플러그인을 사용하는 `MyPhoto` 데모 페이지를 만들었습니다. 이 장에서는 자바스크립트와 CSS를 통해 광범위한 커스터마이징 기능을 제공하는 부트스트랩의 jQuery 플러그인에 대해 자세히 살펴보겠습니다.

우리는 `MyPhoto`에 도입한 플러그인 중 일부를 가져와 살펴보고 페이지의 요구사항을 충족시키기 위해 단계별로 커스터마이징할 것입니다. 페이지를 더 잘 만들 뿐만 아니라 jQuery 플러그인이 어떻게 만들어지고 부트스트랩의 생태계 내에서 작동하는지에 대한 지식을 쌓게 위해 이 장 전체에서 플러그인들을 살펴보고 확장할 것입니다.

부트스트랩의 jQuery 플러그인을 커스터마이징하는 것에 익숙해지기위해 `MyPhoto`용으로 완전히 커스터마이징 된 jQuery 플러그인을 작성합니다.

요약하자면 이 장에서 다음의 것들을 전역적으로 수행할 것입니다.

* 부트스트랩의 jQuery 플러그인의 구조를 알아봅니다.
* 자바스크립트를 통해 부트스트랩의 jQuery의 동작 및 기능을 광범위하게 커스터마이징 하는 방법을 배웁니다.
* CSS를 통해 부트스트랩의 jQuery 플러그인의 스타일을 광범위하게 커스터마이징 하는 방법을 배웁니다.
* 커스텀 부트스트랩 jQuery 플러그인을 처음부터 만드는 방법을 배웁니다.

## 플러그인의 내부

부트스트랩 jQuery 플러그인은 모두 동일한 규칙으로 구성됩니다. 최상위 레벨에서 플러그인은 일반적으로 자바스크립트 파일과 Sass 파일 두 가지의 파일로 분할됩니다. 예를 들어 `Alert` 컴포넌트는 `bootstrap/js/alert.js`와 `bootstrap/scss/_alert.scss`로 구성됩니다. 이 파일들은 부트스트랩의 배포 가능한 자바스크립트 및 CSS 파일의 일부로 컴파일되고 연결됩니다. 플러그인의 내부를 알아보기 위해 이 두 파일은 살펴보겠습니다.

### 자바스크립트

`bootstrap/js/src`에서 자바스크립트 파일을 열면 초기 설정, 클래스 정의, 데이터 API 구현 및 jQuery 익스텐션과 같은 패턴들을 모두 따르는 것을 볼 수 있습니다. `alert.js`에 대해 자세히 살펴보겠습니다.

#### 설정

ECMAScript 2015 스크립트(자바스크립트의 표준 사양으로 ES6이라고도 합니다) 구문으로 작성된 `alert.js` 파일은 유틸리티 모듈을 먼저 임포트 합니다.

```javascript
import Util from './util'
```

**즉시 호출하는 함수 표현식(IIFE-Immediately Invoked Function Expression)**의 결과가 할당된 `Alert`이라는 상수가 있습니다.

```javascript
const Alert = (($) => {
    ...
})(jQuery)
```

`jquery` 객체는 실행을 위해서 함수로 전달되며, 그 결과는 변하지 않는 `Alert` 상수에 할당됩니다.

함수 자체적으로 코드의 나머지 부분에서 사용하기 위한 많은 상수들이 선언됩니다. 파일 시작 부분에 immutables 선언은 일반적인 모범 사례로 간주됩니다. 다음 코드를 살펴보세요.

```javascript
const NAME = 'alert'
const VERSION = '4.0.0-alpha'
const DATA_KEY = 'bs.alert'
const EVENT_KEY = '.${DATA_KEY}'
const DATA_API_KEY = '.data-api'
const JQUERY_NO_CONFLICT = $.fn[NAME]
const TRANSITION_DURATION = 150

const Selector = {
    DISMISS: '[data-dismiss="alert"]'
}
const Event = {
    CLOSE: 'close${EVENT_KEY}',
    CLOSED: 'closed${EVENT_KEY}',
    CLICK_DATA_API: 'click${EVENT_KEY}${DATA_API_KEY}'
}

const ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    IN: 'in'
}
```

`NAME` 속성은 플러그인의 이름이고 `VERSION`은 일반적으로 부트스트랩 버전과 상관되는 플러그인의 버전을 정의합니다. `DATA_KEY`, `EVENT_KEY` 및 `DATA_API_KEY`는 플러그인이 연결하는 데이터 속성들과 관련이 있으며, 나머지는 플러그인 코드 전체에서 사용하느 ㄴ다양한 값에 대한 가독성을 부여한 알리아스(별칭)입니다. 다음은 클래스의 정의입니다.

> **참고**
>
> 즉시 실행 함수 구문(Immediately Invoked Function Expression)
>
> 즉시 실행 함수구문(IIFE 또는 iffy)은 선언된 즉시 실행이 되며, 다른 언어에서는 자체 실행 함수(self-executing function)으로 알려져 있는 함수입니다. 함수는 괄호 안에 함수를 랩핑하거나 앞의 단항 연산자를 포함하고 뒤에 나오는 쌍의 괄호를 포함하여 IIFE로 선언됩니다. 예:
>
> ```javascript
> (function(args){ })(args)
> !function(args){ }(args)
> ```

#### 클래스 정의

플러그인 JS 파일 중 맨 위에 있는 특정 플러그인에 대한 클래스 정의의 시작 부분을 선언하는 주석이 표시됩니다. alert의 경우에는 다음과 같습니다.

```javascript
/**
 * ------------------------------------------------------------------------    
 * Class Definition
 * ------------------------------------------------------------------------
 */
```

클래스 정의는 단순히 기본 객체의 생성자이며 이 경우에는 `Alert` 객체입니다.

```javascript
class Alert {
    constructor(element) {
        this._element = element
    }
    ...
}
```

플러그인 규칙은 Prototypal 상속을 사용하는 것입니다. `Alert` 기본 객체는 다른 모든 `Alert` 유형의 객체가 확장을 하고 상속해야 하는 객체입니다. 클래스 정의에는 `Alert` 클래스의 public 및 private 함수가 있습니다. public `close` 함수를 살펴보겠습니다.

```javascript
close(element) {
    element = element || this._element
    let rootElement = this._getRootElement(element)
    let customEvent = this._triggerCloseEvent(rootElement)
    
    if (customEvent.isDefaultPrevented()) {
        return
    }

    this._removeElement(rootElement)
}
```

`close` 함수를 인자로써 `element`를 받으며, 이 인자는 `close` 함수가 작동 할 DOM 요소에 대한 참조입니다. `close` 함수는 private 함수인 `_getRootElement`를 사용하여 특정 DOM 요소를 검색하고 `_triggerCloseEvent`를 사용하여 처리할 특정 이벤트를 참조합니다. 마지막으로 `_removeElement`를 호출하고 종료합니다. 이러한 private 함수를 살펴보겠습니다.

```javascript
_getRootElement(element) {
    let selector = Util.getSelectorFromElement(element)
    let parent = false

    if (selector) {
        parent = $(selector)[0]
    }

    if (!parent) {
        parent = $(element).closest(`.${ClassName.ALERT}`)[0]
    }
    return parent
}
```

`_getRootElement`는 호출하는 함수에 전달 된 DOM 요소의 부모 요소를 찾습니다(이 경우에는 `close`). 부모가 존재하지 않으면 `_getRootElement`는 플러그인의 초기 설정에서 `ClassName.ALERT`로 정의 된 클래스 이름을 가진 가장 가까운 요소를 반환합니다. 우리의 경우에는 `Alert`입니다. 다음 코드를 살펴보세요.

```javascript
_triggerCloseEvent(element) {
    let closeEvent = $.Event(Event.CLOSE)
    $(element).trigger(closeEvent)
    return closeEvent
}
```

`_triggerCloseEvent`는 요소를 인자로 사용하고 `Event.CLOSE`에 의해 플러그인의 초기 설정에서 참조되는 이벤트를 트리거 합니다.

```javascript
_removeElement(element) {
    $(element).removeClass(ClassName.IN)

    if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element)
        return
    }
    
    $(element)
        .one(Util.TRANSITION_END, $.proxy(this._destroyElement, this, element))
        .emulateTransitionEnd(TRANSITION_DURATION)
}
```

그런 다음 `_removeElement`는 요소 자체의 구성에 따라 또는 플러그인의 초기 설정(예: `TRASITION_DURATION`)에 정의된 대로 `rootElement`를 안전하게 제거합니다.

플러그인의 모든 핵심 동작 및 기능은 `close` 함수와 동일한 방식으로 정의해야 합니다. 클래스 정의는 플러그인의 본질을 나타냅니다.

public과 private 함수가 다음에 static 함수가 옵니다. 이 함수들은 private이기도 하지만 부트스트랩 3에서 플러그인 정의로 설명되는 것과 유사합니다. 다음 코드를 살펴보세요.

```javascript
static _jQueryInterface(config) {
    return this.each(function () {
        let $element = $(this)
        let data = $element.data(DATA_KEY)
        if (!data) {
            data = new Alert(this)
            $element.data(DATA_KEY, data)
        }
        if (config === 'close') {
            data[config](this)
        }
    })
}

static _handleDismiss(alertInstance) {
    return function (event) {
        if (event) {
            event.preventDefault()
        }
        alertInstance.close(this)
    }
}
```

`_jQueryInterface`는 매우 단순합니다. 먼저 DOM 요소 배열을 반복을 합니다. 이 배열은 `this` 객체에 의해 여기에 표시됩니다. 각 요소 주위에 jQuery 래퍼를 만든 다음 이 요소와 연관된 `Alert` 인스턴스가 없다면 만듭니다. `_jQueryInterface`는 `config` 인자를 받습니다. 보시다시피 `_jQueryInterface`와 관련된 `config`의 유일한 값은 `'close'`입니다. `config`가 `'close'`와 같으면 `Alert`이 자동으로 닫힙니다.

`_handleDismiss`를 사용하면 `Alert`의 특정 인스턴스를 프로그래밍 방식으로 닫을 수 잇습니다.

클래스 정의 다음에는 데이터 API 구현이 있습니다.

#### 데이터 API 구현

데이터 API 구현의 역할은 DOM에서 자바스크립트 후을 작성하여 특정 데이터 속성을 사용하는 요소에 대한 동작을 수신하는 것입니다. `alert.js`에는 하나의 후크만 있습니다.

```javascript
$(document).on(
    Event.CLICK_DATA_API,
    Selector.DISMISS,
    Alert._handleDismiss(new Alert())
)
$(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
```

후크는 dismiss 셀렉터와 일치하는 모든 요소의 `on-click` 리스너입니다.

`click`이 등록되면 `Alert`의 닫기 기능이 호출됩니다. dismiss 셀렉터는 실제로 플러그인 설정 안에 파일의 시작 부분에서 정의되어 있습니다.

```javascript
const Selector = {
    DISMISS : '[data-dismiss="alert"]'
}
```

그러므로 `data-dismiss="alert"` 속성을 가진 요소는 클릭을 수신하기 위해 연결이 됩니다. 클릭 이벤트 참조는 설정에서도 정의할 수 있습니다.

```javascript
const Event = {
    CLOSE          : 'close${EVENT_KEY}',
    CLOSED         : 'closed${EVENT_KEY}',
    CLICK_DATA_API : 'click${EVENT_KEY}${DATA_API_KEY}'
}
```

기억하겠지만 `EVENT_KEY`와 `DATA_API_KEY`는 여기에 정의가 됩니다.

```javascript
const DATA_KEY      = 'bs.alert'
const EVENT_KEY     = '.${DATA_KEY}'
const DATA_API_KEY  = '.data-api'
```

실제로 다음과 같이 API 정의를 다시 작성할 수 있습니다.

```javascript
$(document).on(
    'click.bs.alert.data-api', 
    '[data-dismiss="alert"]',
    Alert._handleDismiss(new Alert())
)
```

마지막 부분으로 부트스트랩 4의 새로운 기능인 jQuery 섹션입니다. 부트스트랩 3의 플러그인 정의와 충돌 방지 패턴을 조합한 것입니다.

#### jQuery

jQuery 섹션은 전역 jQuery 객체에 플러그인을 추가하여 jQuery를 애플리케이션이 어디에서나 사용할 수 있도록 합니다. 다음 코드를 살펴보겠습니다.

```javascript
$.fn[NAME] = Alert._jQueryInterface
$.fn[NAME].Constructor = Alert
$.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT
    return Alert._jQueryInterface
}
```

처음 두 개의 할당 된 것은 jQuery의 프로토타입을 플러그인 기능으로 확장한 것입니다. 클로저(Closure) 내에서 `Alert`가 생성되므로 생성자 자체는 실제로 private입니다. `$fn.alert`에서 `Constructor` 속성을 생성하면 public으로 액세스 할 수 있습니다.

그런 다음 `noConflict`라고 하는 `$.fn.alert`의 속성에 `Alert._jQueryInterface` 값이 할당됩니다. `noConflict` 속성은 부트스트랩을 다른 프레임워크와 통합하여 동일한 이름의 두 jQuery 객체가 있는 경우 이 문제를 해결할 때 사용됩니다. 일부 프레임워크에서 부트스트랩 `Alert`가 무시된다면, `noConflict`를 사용하여 부트스트랩 `Alert`에 액세스 하여 이를 새로운 변수에 할당할 수 있습니다.

```javascript
$.fn.bsAlert = $.fn.alert.noConflict()
```

`$.fn.alert`는 `Alert`의 프레임워크 버전입니다. 그러나 우리는 부트스트랩의 `Alert`을 `$.fn.bsAlert`으로 전달했습니다.

모든 플러그인은 초기 설정, 클래스 정의, 데이터 API 구현 및 jQuery 확장 패턴을 따르는 경향이 있습니다. 자바스크립트를 동반하는 플러그인에는 고유한 특정 Sass 스타일 시트가 있습니다.

### Sass

플러그인용 Sass 파일은 해당 자바스크립트와 같은 공식으로 있는 것이 아닙니다. 일반적으로 자바스크립트는 클래스와 속성을 사용하여 일반적으로 간단한 기능을 수행합니다. 대부분의 경우 많은 기능들이 스타일시트에 의해 실제적으로 제어가 됩니다. 자바스크립트는 특정 조건에서 클래스나 요소를 단순히 추가하고 제거를 합니다. 복잡한 리프팅은 일반적으로 Sass에 의해 수행되므로 Sass 자체가 일정한 패턴에 맞지 않을 수도 있습니다.

`sass/_alert.scss`를 살펴보겠습니다. `_alert.scss`는 기본 스타일 정의를 엽니다. 대부분은 아니지만 모든 플러그인에는 기본 정의가 포함됩니다(일반적으로 기본 스타일 또느 ㄴ기본 클래스 주석이 앞에 옵니다). Sass 파일의 시작 부분에 플러그인의 기본 스타일을 정의하는 것은 유지 보수를 위한 모범 사례이며, 플러그인을 확장하여 이를 이해하고자 하는 모든 사용자들을 돕습니다.

기본 스타일을 따르고 플러그인의 기능과 관련되거나 플러그인의 기능에 대한 책이 있는 스타일이 정의됩니다. alert의 경우 무시할 수 있는 alert의 스타일이 정의됩니다. 페이지에 렌더링 되는 것 외에도 경고에 있는 유일한 기능은 해제됩니다. 여기서 경고는 `close` 클래스가 `Alerts` 요소에 적용될 때 발생해야 하는 작업을 정의합니다.

Sass에는 일반적으로 대체 스타일 정의가 포함됩니다. 대체 스타일은 일반적으로 부트스트랩의 컨텍스트 클래스를 할당합니다. **2장. 스타일 구문 만들기**에서 이미 살펴 보았습니다. 다음 코드를 살펴보세요.

```css
// Alternate styles
//
// Generate contextual modifier classes for colorizing the alert.
.alert-success {
    @include alert-variant($alert-success-bg, $alert-success-border, $alert-success-text);
}

.alert-info {
    @include alert-variant($alert-info-bg, $alert-info-border, $alert-info-text);
}

.alert-warning {
    @include alert-variant($alert-warning-bg, $alert-warning-border, $alert-warning-text);
}

.alert-danger {
    @include alert-variant($alert-danger-bg, $alert-danger-border, $alert-danger-text;
}
```

알 수 있듯이 `alert`은 `success`, `info`, `warning` 및 `danger` 상황에 해당하는 스타일을 제공합니다. `$alert-danger-bg`와 같은 규칙에 사용된 변수는 `_variables.scss` 선언되어 있습니다. `_variables.scss` 파일에서 변수를 선언하는 것이 가장 좋습니다. 그렇지 않으면 유지 보수가 매우 어려울 수 있습니다. 예시로 `_variables.scss`를 열고 `$alert-danger-bg`의 정의를 확인합니다.

```css
$alert-warning-bg: $state-warning-bg !default;
```

`$state-warning-bg`는 또 다른 변수이지만 이 변수는 모든 폼의 피드백 및 alert 경고의 배경 변수에서 사용됩니다. alert 컨텍스트가 해당하는 색을 변경하려면 한 자리에서 값을 변경해야 합니다.

```css
$state-warning-bg: #fcf8e3 !default;
```

기본 스타일과 대체 스타일을 넘어서는 Sass 파일을 연결하기 위한 실제 템플릿은 없습니다.

자바스크립트 파일과 Sass 파일은 플러그인을 만드는 두 가지 요소입니다. **4장. 네비게이션, 푸터, 경고 및 콘텐츠** 예제를 보면 실제 `alert` 플러그인을 볼 수 있습니다.

```html
<div class="alert alert-danger">
    <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
    <strong class="alert-heading"><i class="fa fa-exclamation"></i> Unsupported browser</strong> Internet Explorer 8 and lower are not supported by this website.
</div>
```

플러그인 커스터마이징을 시작해보겠습니다.

https://www.packtpub.com/mapt/book/All%20Books/9781783981120/6/ch06lvl1sec40/Customizing+plugins


