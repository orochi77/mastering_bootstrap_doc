# 6장. 플러그인 커스터마이징

지금까지 부트스트랩이 제공하는 모든 것을 사용하고 부트스트랩의 테마와 컴포넌트를 커스터마이징 하며, 그 과정에서 jQuery 플러그인을 사용하는 `MyPhoto` 데모 페이지를 만들었습니다. 이 장에서는 자바스크립트와 CSS를 통해 광범위한 커스터마이징 기능을 제공하는 부트스트랩의 jQuery 플러그인에 대해 자세히 살펴보겠습니다.

우리는 `MyPhoto`에 도입한 플러그인 중 일부를 가져와 살펴보고 페이지의 요구사항을 충족시키기 위해 단계별로 커스터마이징할 것입니다. 페이지를 더 잘 만들 뿐만 아니라 jQuery 플러그인이 어떻게 만들어지고 부트스트랩의 생태계 내에서 작동하는지에 대한 지식을 쌓게 위해 이 장 전체에서 플러그인들을 살펴보고 확장할 것입니다.

부트스트랩의 jQuery 플러그인을 커스터마이징하는 것에 익숙해지기위해 `MyPhoto`용으로 완전히 커스터마이징 된 jQuery 플러그인을 작성합니다.

요약하자면 이 장에서 다음의 것들을 전역적으로 수행할 것입니다.

* 부트스트랩의 jQuery 플러그인의 구조를 알아봅니다.
* 자바스크립트를 통해 부트스트랩의 jQuery의 동작 및 기능을 광범위하게 커스터마이징 하는 방법을 배웁니다.
* CSS를 통해 부트스트랩의 jQuery 플러그인의 스타일을 광범위하게 커스터마이징 하는 방법을 배웁니다.
* 커스텀 부트스트랩 jQuery 플러그인을 처음부터 만드는 방법을 배웁니다.

## 플러그인의 내부

부트스트랩 jQuery 플러그인은 모두 동일한 규칙으로 구성됩니다. 최상위 레벨에서 플러그인은 일반적으로 자바스크립트 파일과 Sass 파일 두 가지의 파일로 분할됩니다. 예를 들어 `Alert` 컴포넌트는 `bootstrap/js/alert.js`와 `bootstrap/scss/_alert.scss`로 구성됩니다. 이 파일들은 부트스트랩의 배포 가능한 자바스크립트 및 CSS 파일의 일부로 컴파일되고 연결됩니다. 플러그인의 내부를 알아보기 위해 이 두 파일은 살펴보겠습니다.

### 자바스크립트

`bootstrap/js/src`에서 자바스크립트 파일을 열면 초기 설정, 클래스 정의, 데이터 API 구현 및 jQuery 익스텐션과 같은 패턴들을 모두 따르는 것을 볼 수 있습니다. `alert.js`에 대해 자세히 살펴보겠습니다.

#### 설정

ECMAScript 2015 스크립트(자바스크립트의 표준 사양으로 ES6이라고도 합니다) 구문으로 작성된 `alert.js` 파일은 유틸리티 모듈을 먼저 임포트 합니다.

```javascript
import Util from './util'
```

**즉시 호출하는 함수 표현식(IIFE-Immediately Invoked Function Expression)**의 결과가 할당된 `Alert`이라는 상수가 있습니다.

```javascript
const Alert = (($) => {
    ...
})(jQuery)
```

`jquery` 객체는 실행을 위해서 함수로 전달되며, 그 결과는 변하지 않는 `Alert` 상수에 할당됩니다.

함수 자체적으로 코드의 나머지 부분에서 사용하기 위한 많은 상수들이 선언됩니다. 파일 시작 부분에 immutables 선언은 일반적인 모범 사례로 간주됩니다. 다음 코드를 살펴보세요.

```javascript
const NAME = 'alert'
const VERSION = '4.0.0-alpha'
const DATA_KEY = 'bs.alert'
const EVENT_KEY = '.${DATA_KEY}'
const DATA_API_KEY = '.data-api'
const JQUERY_NO_CONFLICT = $.fn[NAME]
const TRANSITION_DURATION = 150

const Selector = {
    DISMISS: '[data-dismiss="alert"]'
}
const Event = {
    CLOSE: 'close${EVENT_KEY}',
    CLOSED: 'closed${EVENT_KEY}',
    CLICK_DATA_API: 'click${EVENT_KEY}${DATA_API_KEY}'
}

const ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    IN: 'in'
}
```

`NAME` 속성은 플러그인의 이름이고 `VERSION`은 일반적으로 부트스트랩 버전과 상관되는 플러그인의 버전을 정의합니다. `DATA_KEY`, `EVENT_KEY` 및 `DATA_API_KEY`는 플러그인이 연결하는 데이터 속성들과 관련이 있으며, 나머지는 플러그인 코드 전체에서 사용하느 ㄴ다양한 값에 대한 가독성을 부여한 알리아스(별칭)입니다. 다음은 클래스의 정의입니다.

> **참고**
>
> 즉시 실행 함수 구문(Immediately Invoked Function Expression)
>
> 즉시 실행 함수구문(IIFE 또는 iffy)은 선언된 즉시 실행이 되며, 다른 언어에서는 자체 실행 함수(self-executing function)으로 알려져 있는 함수입니다. 함수는 괄호 안에 함수를 랩핑하거나 앞의 단항 연산자를 포함하고 뒤에 나오는 쌍의 괄호를 포함하여 IIFE로 선언됩니다. 예:
>
> ```javascript
> (function(args){ })(args)
> !function(args){ }(args)
> ```

#### 클래스 정의

플러그인 JS 파일 중 맨 위에 있는 특정 플러그인에 대한 클래스 정의의 시작 부분을 선언하는 주석이 표시됩니다. alert의 경우에는 다음과 같습니다.

```javascript
/**
 * ------------------------------------------------------------------------    
 * Class Definition
 * ------------------------------------------------------------------------
 */
```

클래스 정의는 단순히 기본 객체의 생성자이며 이 경우에는 `Alert` 객체입니다.

```javascript
class Alert {
    constructor(element) {
        this._element = element
    }
    ...
}
```

플러그인 규칙은 Prototypal 상속을 사용하는 것입니다. `Alert` 기본 객체는 다른 모든 `Alert` 유형의 객체가 확장을 하고 상속해야 하는 객체입니다. 클래스 정의에는 `Alert` 클래스의 public 및 private 함수가 있습니다. public `close` 함수를 살펴보겠습니다.

```javascript
close(element) {
    element = element || this._element
    let rootElement = this._getRootElement(element)
    let customEvent = this._triggerCloseEvent(rootElement)
    
    if (customEvent.isDefaultPrevented()) {
        return
    }

    this._removeElement(rootElement)
}
```

`close` 함수를 인자로써 `element`를 받으며, 이 인자는 `close` 함수가 작동 할 DOM 요소에 대한 참조입니다. `close` 함수는 private 함수인 `_getRootElement`를 사용하여 특정 DOM 요소를 검색하고 `_triggerCloseEvent`를 사용하여 처리할 특정 이벤트를 참조합니다. 마지막으로 `_removeElement`를 호출하고 종료합니다. 이러한 private 함수를 살펴보겠습니다.

```javascript
_getRootElement(element) {
    let selector = Util.getSelectorFromElement(element)
    let parent = false

    if (selector) {
        parent = $(selector)[0]
    }

    if (!parent) {
        parent = $(element).closest(`.${ClassName.ALERT}`)[0]
    }
    return parent
}
```

`_getRootElement`는 호출하는 함수에 전달 된 DOM 요소의 부모 요소를 찾습니다(이 경우에는 `close`). 부모가 존재하지 않으면 `_getRootElement`는 플러그인의 초기 설정에서 `ClassName.ALERT`로 정의 된 클래스 이름을 가진 가장 가까운 요소를 반환합니다. 우리의 경우에는 `Alert`입니다. 다음 코드를 살펴보세요.

```javascript
_triggerCloseEvent(element) {
    let closeEvent = $.Event(Event.CLOSE)
    $(element).trigger(closeEvent)
    return closeEvent
}
```

`_triggerCloseEvent`는 요소를 인자로 사용하고 `Event.CLOSE`에 의해 플러그인의 초기 설정에서 참조되는 이벤트를 트리거 합니다.

```javascript
_removeElement(element) {
    $(element).removeClass(ClassName.IN)

    if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element)
        return
    }
    
    $(element)
        .one(Util.TRANSITION_END, $.proxy(this._destroyElement, this, element))
        .emulateTransitionEnd(TRANSITION_DURATION)
}
```

그런 다음 `_removeElement`는 요소 자체의 구성에 따라 또는 플러그인의 초기 설정(예: `TRASITION_DURATION`)에 정의된 대로 `rootElement`를 안전하게 제거합니다.

플러그인의 모든 핵심 동작 및 기능은 `close` 함수와 동일한 방식으로 정의해야 합니다. 클래스 정의는 플러그인의 본질을 나타냅니다.

public과 private 함수가 다음에 static 함수가 옵니다. 이 함수들은 private이기도 하지만 부트스트랩 3에서 플러그인 정의로 설명되는 것과 유사합니다. 다음 코드를 살펴보세요.

```javascript
static _jQueryInterface(config) {
    return this.each(function () {
        let $element = $(this)
        let data = $element.data(DATA_KEY)
        if (!data) {
            data = new Alert(this)
            $element.data(DATA_KEY, data)
        }
        if (config === 'close') {
            data[config](this)
        }
    })
}

static _handleDismiss(alertInstance) {
    return function (event) {
        if (event) {
            event.preventDefault()
        }
        alertInstance.close(this)
    }
}
```

`_jQueryInterface`는 매우 단순합니다. 먼저 DOM 요소 배열을 반복을 합니다. 이 배열은 `this` 객체에 의해 여기에 표시됩니다. 각 요소 주위에 jQuery 래퍼를 만든 다음 이 요소와 연관된 `Alert` 인스턴스가 없다면 만듭니다. `_jQueryInterface`는 `config` 인자를 받습니다. 보시다시피 `_jQueryInterface`와 관련된 `config`의 유일한 값은 `'close'`입니다. `config`가 `'close'`와 같으면 `Alert`이 자동으로 닫힙니다.

`_handleDismiss`를 사용하면 `Alert`의 특정 인스턴스를 프로그래밍 방식으로 닫을 수 잇습니다.

클래스 정의 다음에는 데이터 API 구현이 있습니다.

#### 데이터 API 구현

데이터 API 구현의 역할은 DOM에서 자바스크립트 후을 작성하여 특정 데이터 속성을 사용하는 요소에 대한 동작을 수신하는 것입니다. `alert.js`에는 하나의 후크만 있습니다.

```javascript
$(document).on(
    Event.CLICK_DATA_API,
    Selector.DISMISS,
    Alert._handleDismiss(new Alert())
)
$(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
```

후크는 dismiss 셀렉터와 일치하는 모든 요소의 `on-click` 리스너입니다.

`click`이 등록되면 `Alert`의 닫기 기능이 호출됩니다. dismiss 셀렉터는 실제로 플러그인 설정 안에 파일의 시작 부분에서 정의되어 있습니다.

```javascript
const Selector = {
    DISMISS : '[data-dismiss="alert"]'
}
```

그러므로 `data-dismiss="alert"` 속성을 가진 요소는 클릭을 수신하기 위해 연결이 됩니다. 클릭 이벤트 참조는 설정에서도 정의할 수 있습니다.

```javascript
const Event = {
    CLOSE          : 'close${EVENT_KEY}',
    CLOSED         : 'closed${EVENT_KEY}',
    CLICK_DATA_API : 'click${EVENT_KEY}${DATA_API_KEY}'
}
```

기억하겠지만 `EVENT_KEY`와 `DATA_API_KEY`는 여기에 정의가 됩니다.

```javascript
const DATA_KEY      = 'bs.alert'
const EVENT_KEY     = '.${DATA_KEY}'
const DATA_API_KEY  = '.data-api'
```

실제로 다음과 같이 API 정의를 다시 작성할 수 있습니다.

```javascript
$(document).on(
    'click.bs.alert.data-api', 
    '[data-dismiss="alert"]',
    Alert._handleDismiss(new Alert())
)
```

마지막 부분으로 부트스트랩 4의 새로운 기능인 jQuery 섹션입니다. 부트스트랩 3의 플러그인 정의와 충돌 방지 패턴을 조합한 것입니다.

#### jQuery

jQuery 섹션은 전역 jQuery 객체에 플러그인을 추가하여 jQuery를 애플리케이션이 어디에서나 사용할 수 있도록 합니다. 다음 코드를 살펴보겠습니다.

```javascript
$.fn[NAME] = Alert._jQueryInterface
$.fn[NAME].Constructor = Alert
$.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT
    return Alert._jQueryInterface
}
```

처음 두 개의 할당 된 것은 jQuery의 프로토타입을 플러그인 기능으로 확장한 것입니다. 클로저(Closure) 내에서 `Alert`가 생성되므로 생성자 자체는 실제로 private입니다. `$fn.alert`에서 `Constructor` 속성을 생성하면 public으로 액세스 할 수 있습니다.

그런 다음 `noConflict`라고 하는 `$.fn.alert`의 속성에 `Alert._jQueryInterface` 값이 할당됩니다. `noConflict` 속성은 부트스트랩을 다른 프레임워크와 통합하여 동일한 이름의 두 jQuery 객체가 있는 경우 이 문제를 해결할 때 사용됩니다. 일부 프레임워크에서 부트스트랩 `Alert`가 무시된다면, `noConflict`를 사용하여 부트스트랩 `Alert`에 액세스 하여 이를 새로운 변수에 할당할 수 있습니다.

```javascript
$.fn.bsAlert = $.fn.alert.noConflict()
```

`$.fn.alert`는 `Alert`의 프레임워크 버전입니다. 그러나 우리는 부트스트랩의 `Alert`을 `$.fn.bsAlert`으로 전달했습니다.

모든 플러그인은 초기 설정, 클래스 정의, 데이터 API 구현 및 jQuery 확장 패턴을 따르는 경향이 있습니다. 자바스크립트를 동반하는 플러그인에는 고유한 특정 Sass 스타일 시트가 있습니다.

### Sass

플러그인용 Sass 파일은 해당 자바스크립트와 같은 공식으로 있는 것이 아닙니다. 일반적으로 자바스크립트는 클래스와 속성을 사용하여 일반적으로 간단한 기능을 수행합니다. 대부분의 경우 많은 기능들이 스타일시트에 의해 실제적으로 제어가 됩니다. 자바스크립트는 특정 조건에서 클래스나 요소를 단순히 추가하고 제거를 합니다. 복잡한 리프팅은 일반적으로 Sass에 의해 수행되므로 Sass 자체가 일정한 패턴에 맞지 않을 수도 있습니다.

`sass/_alert.scss`를 살펴보겠습니다. `_alert.scss`는 기본 스타일 정의를 엽니다. 대부분은 아니지만 모든 플러그인에는 기본 정의가 포함됩니다(일반적으로 기본 스타일 또느 ㄴ기본 클래스 주석이 앞에 옵니다). Sass 파일의 시작 부분에 플러그인의 기본 스타일을 정의하는 것은 유지 보수를 위한 모범 사례이며, 플러그인을 확장하여 이를 이해하고자 하는 모든 사용자들을 돕습니다.

기본 스타일을 따르고 플러그인의 기능과 관련되거나 플러그인의 기능에 대한 책이 있는 스타일이 정의됩니다. alert의 경우 무시할 수 있는 alert의 스타일이 정의됩니다. 페이지에 렌더링 되는 것 외에도 경고에 있는 유일한 기능은 해제됩니다. 여기서 경고는 `close` 클래스가 `Alerts` 요소에 적용될 때 발생해야 하는 작업을 정의합니다.

Sass에는 일반적으로 대체 스타일 정의가 포함됩니다. 대체 스타일은 일반적으로 부트스트랩의 컨텍스트 클래스를 할당합니다. **2장. 스타일 구문 만들기**에서 이미 살펴 보았습니다. 다음 코드를 살펴보세요.

```css
// Alternate styles
//
// Generate contextual modifier classes for colorizing the alert.
.alert-success {
    @include alert-variant($alert-success-bg, $alert-success-border, $alert-success-text);
}

.alert-info {
    @include alert-variant($alert-info-bg, $alert-info-border, $alert-info-text);
}

.alert-warning {
    @include alert-variant($alert-warning-bg, $alert-warning-border, $alert-warning-text);
}

.alert-danger {
    @include alert-variant($alert-danger-bg, $alert-danger-border, $alert-danger-text;
}
```

알 수 있듯이 `alert`은 `success`, `info`, `warning` 및 `danger` 상황에 해당하는 스타일을 제공합니다. `$alert-danger-bg`와 같은 규칙에 사용된 변수는 `_variables.scss` 선언되어 있습니다. `_variables.scss` 파일에서 변수를 선언하는 것이 가장 좋습니다. 그렇지 않으면 유지 보수가 매우 어려울 수 있습니다. 예시로 `_variables.scss`를 열고 `$alert-danger-bg`의 정의를 확인합니다.

```css
$alert-warning-bg: $state-warning-bg !default;
```

`$state-warning-bg`는 또 다른 변수이지만 이 변수는 모든 폼의 피드백 및 alert 경고의 배경 변수에서 사용됩니다. alert 컨텍스트가 해당하는 색을 변경하려면 한 자리에서 값을 변경해야 합니다.

```css
$state-warning-bg: #fcf8e3 !default;
```

기본 스타일과 대체 스타일을 넘어서는 Sass 파일을 연결하기 위한 실제 템플릿은 없습니다.

자바스크립트 파일과 Sass 파일은 플러그인을 만드는 두 가지 요소입니다. **4장. 네비게이션, 푸터, 경고 및 콘텐츠** 예제를 보면 실제 `alert` 플러그인을 볼 수 있습니다.

```html
<div class="alert alert-danger">
    <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
    <strong class="alert-heading"><i class="fa fa-exclamation"></i> Unsupported browser</strong> Internet Explorer 8 and lower are not supported by this website.
</div>
```

플러그인 커스터마이징을 시작해보겠습니다.

## 플러그인 커스터마이즈

커스터마이징 할 플러그인이 많이 있지만, 이전 장에서 두 가지를 이미 선택했습니다.

* 부트스트랩의 jQuery 경고(alert) 플러그인
* 부트스트랩의 jQuery 캐러셀(carousel) 플러그인

### 부트스트랩의 jQuery 경고(alert) 플러그인

이미 본것 처럼 alert 플러그인은 매우 간단합니다. alert은 페이지에 표시되고 메시지를 표시하며, 사용자가 특정 요소를 클릭하면 닫아지면서 사라지는 기능만 있습니다.

플러그인을 커스터마이징 하거나 확장하는 방법을 보여주기 위해(이 경우에 alert), 플러그인을 매우 간단하게 유지할 것입니다. 사용자가 특정 요소를 클릭하면 경고가 최소화 되는 기능을 추가할 예정입니다. 또한 최소화 된 상태에서 사용자가 alert을 확장할 수 있는 기능을 제공할 것입니다. 이렇게 하려면 alert의 자바스크립트와 스타일을 확장해야 할 필요가 있습니다.

플러그인 기능 및 스타일을 코딩하기 전에 `MyPhoto`에 alert 마크업을 작성해 보겠습니다.

#### 마크업

사용 사례로써 사용자에게 특정한 제안을 알리는 경고를 표시합니다. 지원하지 않는 브라우저의 경고 위에 알림을 추가합니다.

```html
<div class="alert alert-info" style="position: fixed; margin-top: 4em; width: 90%;margin-left: 4em;">
    <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
    <strong><i class="fa fa-exclamation"></i> Special Offer - </strong>
    <span>2 FOR 1 PRINTS TODAY ONLY WITH PROMO CODE <span style="font-style: italic">BOOTSTRAP</strong></span>
</div>
```

부트스트랩의 상황별 정보 클래스인 `alert-info`를 사용하여 경고 상자의 스타일을 지정하고 있으며, 지원하지 않는 브라우저 경고와 동일한 패턴을 따르고 있습니다. 특별히 제공하는 경고에는 인라인 스타일을 적용하였으며, 지원하지 않는 브라우저 알림에는 ID와 연결된 스타일이 있습니다. 더 자세히 설명하기 전에 재사용성과 유지 보수를 위해 `myphoto.css`의 단일 클래스를 풀어보겠습니다. `#unsupported-browser-alert` 규칙을 제거하고 다음을 추가하세요.

```css
.alert-position {
    position: fixed;
    margin-top: 4em;
    width: 50%;
    margin-left: 25%;
    z-index: 10;
}
.alert-position #unsupported-browser-alert {
    display:none;
}
```

여기에서 약간의 변경을 했습니다. 이제 경고는 뷰포트의 `50%`의 `width`로 설정이 되고 왼쪽에서 `25%` 떨어져서 렌더링이 됩니다. 페이지의 다른 콘텐츠 위에 경고가 항상 표시되도록 하기위해 `z-index`를 `10`으로 설정합니다. 다른 요소의 `z-index`가 더 높지 않다면, 경고는 항상 표시가 됩니다. 이제 alert 요소에서 인라인 스타일을 제거하고 `alert-position` 클래스를 추가합니다. `unsupported-browser-alert` ID가 있는 요소에 대한 클래스를 확장하여 표시되지 않도록 합니다. `alert` 요소를 `alert-position` 클래스로 업데이트 하세요.

```html
<div class="alert alert-info alert-position">
```

다음 스크린 샷을 살펴보기 바랍니다.

![](/assets/image_06_001.jpg)

*그림 6.1*: 특별한 프로모션을 표시하는데 사용하기 위해 수정한 경고입니다. 기본 경고와 달리 너비는 뷰포트의 50%로 고정되어 있고 왼쪽에서부터 25% 떨어진 곳에서 렌더링 됩니다.

좋습니다. 이제 특별한 경고를 가지게 되었습니다. 이제 `minimize`와 `expand` 요소를 추가해보겠습니다. 이 요소들이 `close` 요소와 비슷하게 기능을 하면서 표시되기를 원합니다. 따라서 `close` 요소를 템플릿으로 사용할 수 있습니다. 다음 코드를 살펴보세요.

```html
<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
<a href="#" class="close minimize" data-minimize="alert" aria-label="minimize">_</a>
<a href="#" class="close expand" data-expand="alert" aria-label="expand">+</a>
```

`close` 요소를 두 번 복제했습니다. `close` 클래스가 포함하는 모든 것을 상속받기를 원하며, `close` 요소를 유지하면서 `minimize`와 `expand` 클래스를 추가했습니다. 새로운 데이터 속성이 추가되었습니다. `data-dismiss` 대신 `data-minimize`와 `data-expand`를 넣었습니다. 이것들은 플러그인이 수신하게 될 데이터 속성입니다. 그리고나서 적절한 이름으로 `aria-label`을 업데이트 하고 요소의 내부에 적절한 내용을 적용합니다. 언더스코어(_)는 최소화를 나타내고 플러스(+)는 확장을 나타냅니다(*그림 6.2* 참고). 다음 스크린샷을 살펴보세요.

![](/assets/image_06_002.jpg)

*그림 6.2*: 확장 및 최소화 기능이 추가된 커스텀 프로모션 경고

닫기 버튼 이외에도 확장 및 최소화 버튼이 있습니다. 경고가 이미 펼쳐졌을 때 확장 버튼을 표시하고 싶지 않으며, 경고가 이미 최소화 된 상태에서는 최소화 버튼을 표시하지 않으려 합니다. 경고는 기본적으로 확장 상태이므로 `expand` 요소에 `hidden-sx-up` 클래스를 추가합니다. `hidden-xs-up`은 `xs` 또는 그 이상인 뷰포트에 대해 지정된 요소를 숨깁니다. 즉, 모든 뷰포트에 대한 요소가 숨겨집니다(`hidden-xs-up`은 부트스트랩 3의 `hide`와 같습니다). 다음 코드를 살펴보세요.

```html
<a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
<a href="#" class="close minimize" data-minimize="alert" aria-label="minimize">_</a>
<a href="#" class="close expand hide" data-expand="alert" aria-label="expand">+</a>
```

다음 스크린샷을 살펴보세요.

![](/assets/image_06_003.jpg)

*그림 6.3*: `expand` 요소가 숨겨진 커스텀 프로모션 알림

좋습니다. 경고는 우리가 원하는 방식대로 보이기 시작했습니다. 이를 통해 알림 플러그인의 스타일을 커스터마이징 할 준비가 되었습니다.

#### alert의 스타일시트 확장하기

앞에서 언급한 것 처럼 유지 보수 문제로 부트스트랩의 Sass 파일을 직접 수정하는 것은 좋지 않습니다. 대신, 우리는 우리만의 스타일 시트인 `styles/alert.css`를 만들 것입니다.

새로운 클래스를 만들기 전에 `myphoto.css`에서 경고와 관련한 CSS를 추출하여 코드의 유지 보수 할 수 있도록 향상시켜야 합니다. 우리가 지금까지 했던 유일한 수업은 `alert-danger`와 `alert-position`입니다. 이를 새로운 경고의 특정 스타일 시트에 배치하고 HTML에 스트일 시트를 포함시킵니다. `alert.css`의 스타일 규칙이 우선 적용되도록 하려면 `bootstrap.min.css` 및 `myphoto.css`를 뒤에 이 파일을 포함시키세요. 다음 코드를 살펴보기 바랍니다.

```html
<link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css" />
<link rel="stylesheet" href="styles/myphoto.css" />
<link rel="stylesheet" href="styles/alert.css" />
```

경고를 최소화 하고 확장하는 기능을 만들기 위해서 실제로 많은 스타일 규칙이 필요하지 않습니다. 실제로 우리는 `alert-mnimize`라는 하나의 클래스만을 사용합니다. 사용자가 최소화 버튼을 누를 때 `alert-minimize` 클래스가 루트의 `alert` 요소에 적용됩니다. 경고창이 확장되면, 단순히 `alert-minimize` 클래스가 제거됩니다.

다음의 규칙을 사용하여 `alert.css`를 업데이트 하세요.

```css
.alert-minimize {
    width: 60px;
}

.alert-minimize * {
    display: none;
}

.alert-minimize.close {
    display: block;
}
```

`alert-minimize` 클래스는 `60px`의 요소 너비를 강제로 합니다. `alert-mnimize` 클래스의 모든 하위 항목에는 표시 값이 `none`으로 설정되므로 화면에 나타나지 않습니다. 기능 버튼이 계속 표시되도록 하려면 `close` 클래스가 있는 요소(경고에서 모든 기능 버튼들에 대해 `close` 클래스를 유지했다는 점을 기억하세요)에 `block`의 표시 값이 주어집니다. 경고의 렌더링 방법을 확인하기 위해 수동으로 `alert-minimize`를 적용해보세요. 다음 스크린샷을 살펴보기 바랍니다.

![](/assets/image_06_004.jpg)

*그림 6.4*: 최소화 된 커스텀 프로모션 알림

다음으로 `alert-minimize` 클래스를 제거하고 alert 플러그인의 자바스크립트를 확장하여 클래스를 동적으로 적용하고 제거해보겠습니다.

#### 자바스크립트로 alert의 기능 확장하기

스타일을 확장하는 것 처럼 자바스크립트를 확장하기 위해 부트스트랩의 `alert.js`를 직접 수정할 수도 있지만, 유지보수 측면에서 좋지 않은 방법입니다. 대신 프로젝트에 `js` 디렉토리를 만들고 `alert.js`라는 파일을 만드세요. `bootstrap.min.js` 다음에 이 파일을 HTML에 포함시킵니다.

```html
<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="js/alert.js"></script>
```

먼저 즉시 호출되는 함수를 생성하고 함수를 `jQuery` 객체에 추가하는 것입니다.

```javascript
function ($) {
    'use strict';
    var Alert = $.fn.alert.Constructor;
}(jQuery);
```

이 함수는 alert 플러그인 프로토타입에 `Alert` 변수를 할당합니다. 앞에서 본 것 처럼 `Constructor` 속성을 통해 사용할 수 있습니다.

이 `Alert` 프로토타입에 대한 참조를 통해 우리는 자체적인 함수를 프로토타입에 추가하고 경고 최소화 및 확장을 처리할 수 있습니다. 이전에 확인했던 `close` 함수를 사용하고 몇 가지 변경사항을 적용하여 경고를 최소화하는 함수를 만들어 보겠습니다.

```javascript
Alert.prototype.minimize = function (e) {
    var $this = $(this)
    var selector = $this.attr('data-target')
    if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^s]*$)/, '')
        // strip for ie7
    }
    $this.addClass('hidden-xs-up')
    $this.siblings('.expand').removeClass('hidden-xs-up')
    var $parent = $(selector)
    if (e) e.preventDefault()
    if (!$parent.length) {
        $parent = $this.closest('.alert')
    }
    $parent.trigger(e = $.Event('minimize.bs.alert'))
    if (e.isDefaultPrevented()) return
    $parent.addClass('alert-minimize')
}
```

이 함수는 `close` 함수와 매우 유사하므로 중요한 차이점만을 강조할 것입니다. 15번째 줄과 16번째 줄은 최소화 버튼을 숨기고 확장 버튼을 표시합니다. 그리고 이벤트를 트리거한 요소에 `hide` 클래스를 추가하고 `expand` 클래스가 있는 모든 형제 요소에서 `hide` 클래스를 제거합니다. 32번째 줄에서는 `Alert` 요소의 축소를 처리하는 `alert-minimize` 클래스를 이벤트를 트리거한 요소의 부모에 추가합니다. 기본적으로 `minimize` 함수는 경고를 축소하고 최소화 버튼을 숨기며, 확장 버튼을 표시합니다. 이 함수까지 리스너를 연결합니다.

부트스트랩 alert 플러그인이 `close` 함수로 `click` 이벤트에 `data-dismiss`에 링크하는 것과 같은 방식으로 이 작업을 수행합니다. `alert.js` 다음에 추가하여 `minimize` 함수를 정의합니다.

```javascript
$(document).on(
    'click.bs.alert.data-api', 
    '[data-minimize="alert"]',
    Alert.prototype.minimize
)
```

이제 `"alert"` 값이 있는 `data-minimize`가 있는 요소는 `click` 이벤트에 대해 `Alert.prototype.minimize` 함수를 호출합니다. 특별 제안 알림의 `minimize` 요소에는 이 속성이 있습니다. `MyPhoto`를 열고 최소화 버튼을 클릭하세요. 다음 스크린 샷을 살펴보기 바랍니다.

![](/assets/image_06_005.jpg)

*그림 6.5*: 최소화 된 커스텀 프로모션 알림 - 확장 및 닫기 버튼을 참고하세요.

멋집니다. 최소화 버튼과 그 기능은 특별한 제안 알림을 줄이고, 클릭할 때 최소화 버튼을 확장 버튼으로 올바르게 변경합니다.

마지막으로 해야 할 일은 사용자가 확장 버튼을 클릭할 때 알림을 확장할 수 있는지를 확인하는 것입니다. 이를 위해 우리는 최소화 기능과 동일한 단계를 수행합니다. `Alert` 프로토타입에 `expand` 함수를 추가합니다.

```javascript
Alert.prototype.expand = function (e) {
    var $this = $(this)
    var selector = $this.attr('data-target')
    if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^s]*$)/, '')
        // strip for ie7
    }
    $this.addClass('hidden-xs-up')
    $this.siblings('.minimize').removeClass('hide')
    var $parent = $(selector)
    if (e) e.preventDefault()
    if (!$parent.length) {
        $parent = $this.closest('.alert')
    }
    $parent.trigger(e = $.Event('expand.bs.alert'))
    if (e.isDefaultPrevented()) return
    $parent.removeClass('alert-minimize')
}
```

https://www.packtpub.com/mapt/book/All%20Books/9781783981120/6/ch06lvl1sec40/Customizing+plugins


